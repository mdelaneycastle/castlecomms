rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Recognition Board rules - authenticated users can read and create notes
    match /recognition-notes/{noteId} {
      // Anyone authenticated can read recognition notes
      allow read: if request.auth != null;
      
      // Authenticated users can create new notes with proper validation
      allow create: if request.auth != null 
        && validateRecognitionNote(request.resource.data);
      
      // Only admins can update or delete notes
      allow update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Drawing Noticeboard rules - authenticated users can read and create drawings
    match /drawings/{drawingId} {
      // Anyone authenticated can read drawings
      allow read: if request.auth != null;
      
      // Authenticated users can create new drawings with proper validation
      allow create: if request.auth != null 
        && validateDrawing(request.resource.data);
      
      // Only admins can update or delete drawings
      allow update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Messages rules - users can read messages sent to them and create messages
    match /messages/{messageId} {
      // Users can read messages if they are in the recipients list
      allow read: if request.auth != null 
        && request.auth.token.email in resource.data.recipients;
      
      // Authenticated users can create messages with proper validation
      allow create: if request.auth != null 
        && validateMessage(request.resource.data);
      
      // Users can update messages to mark them as read
      allow update: if request.auth != null 
        && request.auth.token.email in resource.data.recipients
        && onlyUpdatingReadStatus(request.resource.data, resource.data);
      
      // Only admins can delete messages
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate recognition note data
    function validateRecognitionNote(data) {
      return data.keys().hasAll(['content', 'author', 'timestamp'])
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 300
        && data.author is string
        && data.author.size() <= 50
        && data.timestamp is timestamp;
    }
    
    // Helper function to validate drawing data
    function validateDrawing(data) {
      return data.keys().hasAll(['imageData', 'timestamp', 'position'])
        && data.imageData is string
        && data.imageData.size() > 0
        && data.timestamp is timestamp
        && data.position is map
        && data.position.keys().hasAll(['x', 'y'])
        && data.position.x is number
        && data.position.y is number;
    }
    
    // Helper function to validate message data
    function validateMessage(data) {
      return data.keys().hasAll(['senderId', 'senderEmail', 'senderName', 'message', 'recipients', 'timestamp'])
        && data.senderId is string
        && data.senderId.size() > 0
        && data.senderEmail is string
        && data.senderEmail.size() > 0
        && data.senderName is string
        && data.senderName.size() > 0
        && data.message is string
        && data.message.size() > 0
        && data.message.size() <= 2000
        && data.recipients is list
        && data.recipients.size() > 0
        && data.timestamp is timestamp;
    }
    
    // Helper function to check if only read status is being updated
    function onlyUpdatingReadStatus(newData, oldData) {
      return newData.keys() == oldData.keys()
        && newData.senderId == oldData.senderId
        && newData.senderEmail == oldData.senderEmail
        && newData.senderName == oldData.senderName
        && newData.message == oldData.message
        && newData.recipients == oldData.recipients
        && newData.timestamp == oldData.timestamp;
    }
    
    // Tickets rules - users can read tickets they created or are assigned to
    match /tickets/{ticketId} {
      // Allow authenticated users to read tickets (security handled by queries)
      allow read: if request.auth != null;
      
      // Authenticated users can create tickets with proper validation
      allow create: if request.auth != null 
        && validateTicket(request.resource.data);
      
      // Ticket creator, individual assignee, or any authenticated user for team tickets can update
      allow update: if request.auth != null 
        && (request.auth.uid == resource.data.createdBy.uid 
            || request.auth.token.email == resource.data.assignedTo.email
            || resource.data.assignedTo.type == 'team')
        && validateTicketUpdate(request.resource.data, resource.data);
      
      // Only admins can delete tickets
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate ticket data
    function validateTicket(data) {
      return data.keys().hasAll(['ticketId', 'title', 'description', 'category', 'status', 'createdBy', 'assignedTo', 'createdAt'])
        && data.ticketId is string
        && data.ticketId.size() > 0
        && data.title is string
        && data.title.size() > 0
        && data.title.size() <= 200
        && data.description is string
        && data.description.size() > 0
        && data.description.size() <= 3000
        && data.category is string
        && data.category.size() > 0
        && data.status in ['open', 'in-progress', 'on-hold', 'resolved']
        && data.createdBy is map
        && data.createdBy.keys().hasAll(['uid', 'email', 'name'])
        && data.assignedTo is map
        && validateTicketAssignment(data.assignedTo)
        && data.createdAt is timestamp
        // Allow optional fields
        && (!('messages' in data) || data.messages is list)
        && (!('timer' in data) || data.timer is map)
        && (!('priority' in data) || data.priority is string)
        && (!('updatedAt' in data) || data.updatedAt is timestamp);
    }
    
    // Helper function to validate ticket assignment (individual or team)
    function validateTicketAssignment(assignedTo) {
      return (
        // Individual assignment
        (assignedTo.type == 'individual' 
         && assignedTo.keys().hasAll(['type', 'email', 'name'])
         && assignedTo.email is string
         && assignedTo.name is string)
        ||
        // Team assignment (new format with teamId)
        (assignedTo.type == 'team'
         && assignedTo.keys().hasAll(['type', 'teamName', 'teamId'])
         && assignedTo.teamName is string
         && assignedTo.teamId is string)
        ||
        // Team assignment (legacy format with teamMembers)
        (assignedTo.type == 'team'
         && assignedTo.keys().hasAll(['type', 'teamName', 'teamMembers'])
         && assignedTo.teamName is string
         && assignedTo.teamMembers is list)
        ||
        // Legacy format (backwards compatibility)
        ((!('type' in assignedTo))
         && assignedTo.keys().hasAll(['email', 'name'])
         && assignedTo.email is string
         && assignedTo.name is string)
      );
    }
    
    // Helper function to check if user is a member of a team
    function userIsTeamMember(userEmail, teamMembers) {
      // Check if the user email exists in the team members list
      // This is a simplified check that works with Firestore rules limitations
      return userEmail in teamMembers || 
             string(teamMembers).matches('.*' + userEmail + '.*');
    }
    
    // Helper function to validate ticket updates
    function validateTicketUpdate(newData, oldData) {
      return newData.ticketId == oldData.ticketId
        && newData.createdBy == oldData.createdBy
        && newData.createdAt == oldData.createdAt
        // Allow title, description, and category to be updated
        && (!('title' in newData) || (newData.title is string && newData.title.size() > 0 && newData.title.size() <= 200))
        && (!('description' in newData) || (newData.description is string && newData.description.size() > 0 && newData.description.size() <= 3000))
        && (!('category' in newData) || (newData.category is string && newData.category.size() > 0))
        // Allow status updates with validation
        && (!('status' in newData) || newData.status in ['open', 'in-progress', 'on-hold', 'resolved', 'transferred'])
        // Allow assignedTo to change for transfers, but validate the new assignment
        && (!('assignedTo' in newData) || validateTicketAssignment(newData.assignedTo));
    }
    
    // Communications rules - all authenticated users can read, only admins can write
    match /communications/{commId} {
      // Anyone authenticated can read communications
      allow read: if request.auth != null;
      
      // Only admins can create, update, and delete communications
      allow create, update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Communication reads tracking - users can manage their own read status, admins can read all for analytics
    match /communication-reads/{readId} {
      // Users can read their own read status records, admins can read all for analytics
      allow read: if request.auth != null 
        && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      
      // Users can create and delete their own read status records
      allow create, delete: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
    }
    
    // Communication tasks tracking - users can manage their own task completions, admins can read all for analytics
    match /communication-tasks/{taskId} {
      // Users can read their own task completion records, admins can read all for analytics
      allow read: if request.auth != null 
        && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      
      // Users can create and delete their own task completion records
      allow create, delete: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
    }
    
    // User reports rules - users can manage their own saved reports
    match /user-reports/{userId} {
      // Users can only read and write their own reports
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // User preferences rules - users can manage their own preferences
    match /user-preferences/{userId} {
      // Users can only read, write and delete their own preferences
      allow read, write, delete: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // Chat system rules - authenticated users can participate in chats they're part of
    match /chats/{chatId} {
      // Users can read chats they are participants in
      allow read: if request.auth != null 
        && request.auth.token.email in resource.data.participants;
      
      // Authenticated users can create chats with proper validation
      allow create: if request.auth != null 
        && validateChat(request.resource.data)
        && request.auth.token.email in request.resource.data.participants;
      
      // Only participants can update chat metadata
      allow update: if request.auth != null 
        && request.auth.token.email in resource.data.participants
        && validateChatUpdate(request.resource.data, resource.data);
      
      // Only participants can delete chats
      allow delete: if request.auth != null 
        && request.auth.token.email in resource.data.participants;
    }
    
    // Chat messages rules - participants can read/write messages in their chats
    match /chat-messages/{messageId} {
      // Users can read messages from chats they participate in
      allow read: if request.auth != null 
        && chatParticipantCheck(resource.data.chatId);
      
      // Authenticated users can create messages in chats they participate in
      allow create: if request.auth != null 
        && validateChatMessage(request.resource.data)
        && chatParticipantCheck(request.resource.data.chatId);
      
      // Only message sender can update messages (for read receipts)
      allow update: if request.auth != null 
        && (request.auth.token.email == resource.data.senderEmail 
            || onlyUpdatingReadReceipts(request.resource.data, resource.data));
      
      // Only message sender and chat participants can delete messages
      allow delete: if request.auth != null 
        && (request.auth.token.email == resource.data.senderEmail 
            || chatParticipantCheck(resource.data.chatId));
    }
    
    // Chat typing indicators - participants can manage typing status
    match /chat-typing/{typingId} {
      // Users can read typing indicators from chats they participate in
      allow read: if request.auth != null 
        && chatParticipantCheck(resource.data.chatId);
      
      // Users can create their own typing indicators
      allow create: if request.auth != null 
        && (request.auth.token.email == request.resource.data.userEmail 
            || request.auth.uid == request.resource.data.userId)
        && chatParticipantCheck(request.resource.data.chatId);
      
      // Users can update/delete their own typing indicators  
      allow update, delete: if request.auth != null 
        && (request.auth.token.email == resource.data.userEmail 
            || request.auth.uid == resource.data.userId 
            || typingId.matches('.*' + request.auth.token.email + '.*'))
        && chatParticipantCheck(resource.data.chatId);
    }
    
    // Helper function to check if user is a chat participant
    function chatParticipantCheck(chatId) {
      return exists(/databases/$(database)/documents/chats/$(chatId)) 
        && request.auth.token.email in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }
    
    // Helper function to validate chat data
    function validateChat(data) {
      return data.keys().hasAll(['name', 'participants', 'createdBy', 'createdAt'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.participants is list
        && data.participants.size() > 0
        && data.createdBy is string
        && data.createdBy.size() > 0
        && data.createdAt is timestamp;
    }
    
    // Helper function to validate chat updates
    function validateChatUpdate(newData, oldData) {
      return newData.participants == oldData.participants
        && newData.createdBy == oldData.createdBy
        && newData.createdAt == oldData.createdAt;
    }
    
    // Helper function to validate chat message data
    function validateChatMessage(data) {
      return data.keys().hasAll(['chatId', 'senderEmail', 'senderName', 'message', 'timestamp'])
        && data.chatId is string
        && data.chatId.size() > 0
        && data.senderEmail is string
        && data.senderEmail.size() > 0
        && data.senderName is string
        && data.senderName.size() > 0
        && data.message is string
        && (data.message.size() > 0 || ('attachments' in data && data.attachments is list && data.attachments.size() > 0))
        && data.message.size() <= 2000
        && data.timestamp is timestamp
        && (!('attachments' in data) || (data.attachments is list && data.attachments.size() <= 10));
    }
    
    // Helper function to check if only read receipts are being updated
    function onlyUpdatingReadReceipts(newData, oldData) {
      return newData.chatId == oldData.chatId
        && newData.senderEmail == oldData.senderEmail
        && newData.senderName == oldData.senderName
        && newData.message == oldData.message
        && newData.timestamp == oldData.timestamp;
    }

    // Teams rules - authenticated users can read all teams, admins can manage teams
    match /teams/{teamId} {
      // All authenticated users can read teams (for assignment purposes)
      allow read: if request.auth != null;
      
      // Only admins can create teams with proper validation
      allow create: if request.auth != null 
        && request.auth.token.admin == true
        && validateTeam(request.resource.data);
      
      // Only admins can update teams
      allow update: if request.auth != null 
        && request.auth.token.admin == true
        && validateTeamUpdate(request.resource.data, resource.data);
      
      // Only admins can delete teams
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate team data
    function validateTeam(data) {
      return data.keys().hasAll(['name', 'description', 'members', 'createdAt', 'createdBy'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.description is string
        && data.description.size() <= 500
        && data.members is list
        && data.createdAt is timestamp
        && data.createdBy is map
        && data.createdBy.keys().hasAll(['uid', 'email', 'name']);
    }
    
    // Helper function to validate team updates
    function validateTeamUpdate(newData, oldData) {
      return newData.createdAt == oldData.createdAt
        && newData.createdBy == oldData.createdBy;
    }

    // Tasks rules - users can manage their own tasks
    match /tasks/{taskId} {
      // Users can only read their own tasks
      allow read: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      
      // Users can create their own tasks with proper validation
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateTask(request.resource.data);
      
      // Users can update their own tasks
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && validateTaskUpdate(request.resource.data, resource.data);
      
      // Users can delete their own tasks
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }

    // Custom checklists rules - users can manage their own custom checklists
    match /custom-checklists/{checklistId} {
      // Users can only read their own custom checklists
      allow read: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      
      // Users can create their own custom checklists with proper validation
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateCustomChecklist(request.resource.data);
      
      // Users can update their own custom checklists
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      
      // Users can delete their own custom checklists
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }

    // Completed checklists rules - users can manage their own completed checklists
    match /completed-checklists/{completedChecklistId} {
      // Users can only read their own completed checklists
      allow read: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      
      // Users can create their own completed checklists with proper validation
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && validateCompletedChecklist(request.resource.data);
      
      // Users can update their own completed checklists (for additional notes, etc.)
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId;
      
      // Users can delete their own completed checklists
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }

    // Helper function to validate task data
    function validateTask(data) {
      return data.keys().hasAll(['title', 'status', 'userId', 'userEmail'])
        && data.title is string
        && data.title.size() > 0
        && data.title.size() <= 200
        && data.status in ['pending', 'in-progress', 'completed']
        && data.userId is string
        && data.userEmail is string
        && (!('description' in data) || (data.description is string && data.description.size() <= 1000))
        && (!('dueDate' in data) || data.dueDate is string)
        && (!('requiresPhotos' in data) || data.requiresPhotos is bool)
        && (!('priority' in data) || data.priority in ['low', 'medium', 'high']);
    }

    // Helper function to validate task updates
    function validateTaskUpdate(newData, oldData) {
      return newData.userId == oldData.userId
        && newData.userEmail == oldData.userEmail
        && (!('createdAt' in newData) || newData.createdAt == oldData.createdAt);
    }

    // Helper function to validate custom checklist data
    function validateCustomChecklist(data) {
      return data.keys().hasAll(['name', 'userId', 'userEmail', 'items'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.userId is string
        && data.userEmail is string
        && data.items is list
        && data.items.size() > 0
        && (!('description' in data) || (data.description is string && data.description.size() <= 500))
        && (!('category' in data) || data.category is string);
    }

    // Helper function to validate completed checklist data
    function validateCompletedChecklist(data) {
      return data.keys().hasAll(['checklistType', 'userId', 'userEmail'])
        && data.checklistType is string
        && data.userId is string
        && data.userEmail is string
        && (!('signature' in data) || data.signature is string)
        && (!('passRate' in data) || data.passRate is number);
    }

    // Default deny for all other documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}