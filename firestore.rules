rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Recognition Board rules - authenticated users can read and create notes
    match /recognition-notes/{noteId} {
      // Anyone authenticated can read recognition notes
      allow read: if request.auth != null;
      
      // Authenticated users can create new notes with proper validation
      allow create: if request.auth != null 
        && validateRecognitionNote(request.resource.data);
      
      // Only admins can update or delete notes
      allow update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Drawing Noticeboard rules - authenticated users can read and create drawings
    match /drawings/{drawingId} {
      // Anyone authenticated can read drawings
      allow read: if request.auth != null;
      
      // Authenticated users can create new drawings with proper validation
      allow create: if request.auth != null 
        && validateDrawing(request.resource.data);
      
      // Only admins can update or delete drawings
      allow update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Messages rules - users can read messages sent to them and create messages
    match /messages/{messageId} {
      // Users can read messages if they are in the recipients list
      allow read: if request.auth != null 
        && request.auth.token.email in resource.data.recipients;
      
      // Authenticated users can create messages with proper validation
      allow create: if request.auth != null 
        && validateMessage(request.resource.data);
      
      // Users can update messages to mark them as read
      allow update: if request.auth != null 
        && request.auth.token.email in resource.data.recipients
        && onlyUpdatingReadStatus(request.resource.data, resource.data);
      
      // Only admins can delete messages
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate recognition note data
    function validateRecognitionNote(data) {
      return data.keys().hasAll(['content', 'author', 'timestamp'])
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 300
        && data.author is string
        && data.author.size() <= 50
        && data.timestamp is timestamp;
    }
    
    // Helper function to validate drawing data
    function validateDrawing(data) {
      return data.keys().hasAll(['imageData', 'timestamp', 'position'])
        && data.imageData is string
        && data.imageData.size() > 0
        && data.timestamp is timestamp
        && data.position is map
        && data.position.keys().hasAll(['x', 'y'])
        && data.position.x is number
        && data.position.y is number;
    }
    
    // Helper function to validate message data
    function validateMessage(data) {
      return data.keys().hasAll(['senderId', 'senderEmail', 'senderName', 'message', 'recipients', 'timestamp'])
        && data.senderId is string
        && data.senderId.size() > 0
        && data.senderEmail is string
        && data.senderEmail.size() > 0
        && data.senderName is string
        && data.senderName.size() > 0
        && data.message is string
        && data.message.size() > 0
        && data.message.size() <= 2000
        && data.recipients is list
        && data.recipients.size() > 0
        && data.timestamp is timestamp;
    }
    
    // Helper function to check if only read status is being updated
    function onlyUpdatingReadStatus(newData, oldData) {
      return newData.keys() == oldData.keys()
        && newData.senderId == oldData.senderId
        && newData.senderEmail == oldData.senderEmail
        && newData.senderName == oldData.senderName
        && newData.message == oldData.message
        && newData.recipients == oldData.recipients
        && newData.timestamp == oldData.timestamp;
    }
    
    // Tickets rules - users can read tickets they created or are assigned to
    match /tickets/{ticketId} {
      // Allow authenticated users to read tickets (security handled by queries)
      allow read: if request.auth != null;
      
      // Authenticated users can create tickets with proper validation
      allow create: if request.auth != null 
        && validateTicket(request.resource.data);
      
      // Only ticket creator and assignee can update tickets
      allow update: if request.auth != null 
        && (request.auth.uid == resource.data.createdBy.uid 
            || request.auth.token.email == resource.data.assignedTo.email)
        && validateTicketUpdate(request.resource.data, resource.data);
      
      // Only admins can delete tickets
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate ticket data
    function validateTicket(data) {
      return data.keys().hasAll(['ticketId', 'title', 'description', 'category', 'status', 'createdBy', 'assignedTo', 'createdAt'])
        && data.ticketId is string
        && data.ticketId.size() > 0
        && data.title is string
        && data.title.size() > 0
        && data.title.size() <= 100
        && data.description is string
        && data.description.size() > 0
        && data.description.size() <= 2000
        && data.category is string
        && data.category.size() > 0
        && data.status in ['open', 'on-hold', 'resolved']
        && data.createdBy is map
        && data.createdBy.keys().hasAll(['uid', 'email', 'name'])
        && data.assignedTo is map
        && validateTicketAssignment(data.assignedTo)
        && data.createdAt is timestamp;
    }
    
    // Helper function to validate ticket assignment (individual or team)
    function validateTicketAssignment(assignedTo) {
      return (
        // Individual assignment
        (assignedTo.type == 'individual' 
         && assignedTo.keys().hasAll(['type', 'email', 'name'])
         && assignedTo.email is string
         && assignedTo.name is string)
        ||
        // Team assignment
        (assignedTo.type == 'team'
         && assignedTo.keys().hasAll(['type', 'teamId', 'teamName', 'teamMembers'])
         && assignedTo.teamId is string
         && assignedTo.teamName is string
         && assignedTo.teamMembers is list)
        ||
        // Legacy format (backwards compatibility)
        ((!('type' in assignedTo))
         && assignedTo.keys().hasAll(['email', 'name'])
         && assignedTo.email is string
         && assignedTo.name is string)
      );
    }
    
    // Helper function to validate ticket updates
    function validateTicketUpdate(newData, oldData) {
      return newData.ticketId == oldData.ticketId
        && newData.title == oldData.title
        && newData.description == oldData.description
        && newData.category == oldData.category
        && newData.createdBy == oldData.createdBy
        && newData.assignedTo == oldData.assignedTo
        && newData.createdAt == oldData.createdAt;
    }
    
    // Communications rules - all authenticated users can read, only admins can write
    match /communications/{commId} {
      // Anyone authenticated can read communications
      allow read: if request.auth != null;
      
      // Only admins can create, update, and delete communications
      allow create, update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Communication reads tracking - users can manage their own read status, admins can read all for analytics
    match /communication-reads/{readId} {
      // Users can read their own read status records, admins can read all for analytics
      allow read: if request.auth != null 
        && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      
      // Users can create and delete their own read status records
      allow create, delete: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
    }
    
    // Communication tasks tracking - users can manage their own task completions, admins can read all for analytics
    match /communication-tasks/{taskId} {
      // Users can read their own task completion records, admins can read all for analytics
      allow read: if request.auth != null 
        && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      
      // Users can create and delete their own task completion records
      allow create, delete: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
    }
    
    // User reports rules - users can manage their own saved reports
    match /user-reports/{userId} {
      // Users can only read and write their own reports
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // User preferences rules - users can manage their own preferences
    match /user-preferences/{userId} {
      // Users can only read, write and delete their own preferences
      allow read, write, delete: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // Chat system rules - authenticated users can participate in chats they're part of
    match /chats/{chatId} {
      // Users can read chats they are participants in
      allow read: if request.auth != null 
        && request.auth.token.email in resource.data.participants;
      
      // Authenticated users can create chats with proper validation
      allow create: if request.auth != null 
        && validateChat(request.resource.data)
        && request.auth.token.email in request.resource.data.participants;
      
      // Only participants can update chat metadata
      allow update: if request.auth != null 
        && request.auth.token.email in resource.data.participants
        && validateChatUpdate(request.resource.data, resource.data);
      
      // Only participants can delete chats
      allow delete: if request.auth != null 
        && request.auth.token.email in resource.data.participants;
    }
    
    // Chat messages rules - participants can read/write messages in their chats
    match /chat-messages/{messageId} {
      // Users can read messages from chats they participate in
      allow read: if request.auth != null 
        && chatParticipantCheck(resource.data.chatId);
      
      // Authenticated users can create messages in chats they participate in
      allow create: if request.auth != null 
        && validateChatMessage(request.resource.data)
        && chatParticipantCheck(request.resource.data.chatId);
      
      // Only message sender can update messages (for read receipts)
      allow update: if request.auth != null 
        && (request.auth.token.email == resource.data.senderEmail 
            || onlyUpdatingReadReceipts(request.resource.data, resource.data));
      
      // Only message sender and chat participants can delete messages
      allow delete: if request.auth != null 
        && (request.auth.token.email == resource.data.senderEmail 
            || chatParticipantCheck(resource.data.chatId));
    }
    
    // Chat typing indicators - participants can manage typing status
    match /chat-typing/{typingId} {
      // Users can read typing indicators from chats they participate in
      allow read: if request.auth != null 
        && chatParticipantCheck(resource.data.chatId);
      
      // Users can create/update/delete their own typing indicators
      allow create, update, delete: if request.auth != null 
        && request.auth.token.email == request.resource.data.userEmail
        && chatParticipantCheck(request.resource.data.chatId);
    }
    
    // Helper function to check if user is a chat participant
    function chatParticipantCheck(chatId) {
      return exists(/databases/$(database)/documents/chats/$(chatId)) 
        && request.auth.token.email in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }
    
    // Helper function to validate chat data
    function validateChat(data) {
      return data.keys().hasAll(['name', 'participants', 'createdBy', 'createdAt'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.participants is list
        && data.participants.size() > 0
        && data.createdBy is string
        && data.createdBy.size() > 0
        && data.createdAt is timestamp;
    }
    
    // Helper function to validate chat updates
    function validateChatUpdate(newData, oldData) {
      return newData.participants == oldData.participants
        && newData.createdBy == oldData.createdBy
        && newData.createdAt == oldData.createdAt;
    }
    
    // Helper function to validate chat message data
    function validateChatMessage(data) {
      return data.keys().hasAll(['chatId', 'senderEmail', 'senderName', 'message', 'timestamp'])
        && data.chatId is string
        && data.chatId.size() > 0
        && data.senderEmail is string
        && data.senderEmail.size() > 0
        && data.senderName is string
        && data.senderName.size() > 0
        && data.message is string
        && (data.message.size() > 0 || ('attachments' in data && data.attachments is list && data.attachments.size() > 0))
        && data.message.size() <= 2000
        && data.timestamp is timestamp
        && (!('attachments' in data) || (data.attachments is list && data.attachments.size() <= 10));
    }
    
    // Helper function to check if only read receipts are being updated
    function onlyUpdatingReadReceipts(newData, oldData) {
      return newData.chatId == oldData.chatId
        && newData.senderEmail == oldData.senderEmail
        && newData.senderName == oldData.senderName
        && newData.message == oldData.message
        && newData.timestamp == oldData.timestamp;
    }

    // Teams rules - authenticated users can read all teams, admins can manage teams
    match /teams/{teamId} {
      // All authenticated users can read teams (for assignment purposes)
      allow read: if request.auth != null;
      
      // Only admins can create teams with proper validation
      allow create: if request.auth != null 
        && request.auth.token.admin == true
        && validateTeam(request.resource.data);
      
      // Only admins can update teams
      allow update: if request.auth != null 
        && request.auth.token.admin == true
        && validateTeamUpdate(request.resource.data, resource.data);
      
      // Only admins can delete teams
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Helper function to validate team data
    function validateTeam(data) {
      return data.keys().hasAll(['name', 'description', 'members', 'createdAt', 'createdBy'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.description is string
        && data.description.size() <= 500
        && data.members is list
        && data.createdAt is timestamp
        && data.createdBy is map
        && data.createdBy.keys().hasAll(['uid', 'email', 'name']);
    }
    
    // Helper function to validate team updates
    function validateTeamUpdate(newData, oldData) {
      return newData.createdAt == oldData.createdAt
        && newData.createdBy == oldData.createdBy;
    }

    // Default deny for all other documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}