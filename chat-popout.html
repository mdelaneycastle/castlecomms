<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chat - Castle Comms</title>
  
  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <style>
    :root {
      --primary-color: #6264a7;
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --border-radius: 8px;
      --shadow-light: 0 2px 4px rgba(0, 0, 0, 0.1);
      --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f8f9fa;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Compact Header */
    .popout-header {
      background: var(--primary-gradient);
      color: white;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: var(--shadow-medium);
      flex-shrink: 0;
      font-size: 14px;
    }

    .header-title {
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chat-selector {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      max-width: 150px;
    }

    .chat-selector option {
      background: var(--primary-color);
      color: white;
    }

    /* Main Chat Container */
    .popout-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      position: relative;
      overflow: hidden;
    }

    /* Chat Messages Area */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      background: #f8f9fa;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }

    /* Message Groups */
    .message-group {
      margin-bottom: 16px;
    }

    .message-group.own {
      text-align: right;
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 11px;
      color: #6c757d;
    }

    .message-header.own {
      justify-content: flex-end;
    }

    .message-avatar {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary-gradient);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: bold;
    }

    .message-sender {
      font-weight: 500;
      font-size: 11px;
    }

    .message-time {
      font-size: 10px;
      opacity: 0.7;
    }

    .message-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 8px 12px;
      border-radius: 12px;
      margin-bottom: 2px;
      word-wrap: break-word;
      font-size: 13px;
      line-height: 1.4;
    }

    .message-group:not(.own) .message-bubble {
      background: #e5e5ea;
      color: #000;
      border-bottom-left-radius: 4px;
    }

    .message-group.own .message-bubble {
      background: var(--primary-color);
      color: white;
      border-bottom-right-radius: 4px;
    }

    /* Typing Indicators */
    .typing-indicators {
      padding: 4px 12px;
      font-size: 11px;
      color: #8a8886;
      font-style: italic;
      min-height: 16px;
    }

    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .typing-dots {
      display: inline-flex;
      gap: 2px;
    }

    .typing-dot {
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: #8a8886;
      animation: typingPulse 1.5s infinite;
    }

    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.3s; }
    .typing-dot:nth-child(3) { animation-delay: 0.6s; }

    @keyframes typingPulse {
      0%, 60%, 100% { opacity: 0.3; }
      30% { opacity: 1; }
    }

    /* Input Area */
    .chat-input-area {
      border-top: 1px solid #e5e5e5;
      background: white;
      flex-shrink: 0;
    }

    .chat-input-container {
      display: flex;
      padding: 8px;
      gap: 8px;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      border: 1px solid #e5e5e5;
      border-radius: 16px;
      padding: 8px 12px;
      font-size: 13px;
      resize: none;
      outline: none;
      background: #f8f9fa;
      max-height: 80px;
      min-height: 32px;
    }

    .chat-input:focus {
      border-color: var(--primary-color);
      background: white;
    }

    .send-button {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 16px;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      height: 32px;
      font-weight: 500;
    }

    .send-button:hover:not(:disabled) {
      background: #585a96;
    }

    .send-button:disabled {
      background: #c8c6c4;
      cursor: not-allowed;
    }

    /* Empty State */
    .chat-empty {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8a8886;
      text-align: center;
      padding: 20px;
    }

    .chat-empty-icon {
      font-size: 32px;
      margin-bottom: 12px;
    }

    /* Ticket Links */
    .ticket-link {
      color: #6264a7;
      text-decoration: none;
      font-weight: 600;
      padding: 1px 4px;
      border-radius: 3px;
      background: rgba(98, 100, 167, 0.1);
      border: 1px solid rgba(98, 100, 167, 0.2);
      transition: all 0.2s ease;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 2px;
      font-size: 11px;
    }

    .ticket-link:hover {
      background: rgba(98, 100, 167, 0.15);
      border-color: rgba(98, 100, 167, 0.3);
      text-decoration: none;
    }

    .ticket-link::before {
      content: "ðŸ“‹";
      font-size: 10px;
    }

    /* Ticket Preview Card - compact for popout */
    .ticket-preview {
      position: fixed;
      background: white;
      border: 1px solid #e1e1e1;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      min-width: 250px;
      max-width: 280px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-8px);
      transition: all 0.2s ease;
    }

    .ticket-preview.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }

    .ticket-preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
      padding-bottom: 4px;
      border-bottom: 1px solid #f0f0f0;
    }

    .ticket-preview-id {
      font-weight: 600;
      color: #6264a7;
      font-size: 11px;
    }

    .ticket-preview-status {
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 9px;
      font-weight: 500;
      text-transform: uppercase;
    }

    .ticket-preview-status.open {
      background: #e3f2fd;
      color: #1976d2;
    }

    .ticket-preview-status.resolved {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .ticket-preview-status.in-progress {
      background: #fff3e0;
      color: #f57c00;
    }

    .ticket-preview-title {
      font-weight: 600;
      color: #323130;
      margin-bottom: 4px;
      line-height: 1.3;
      font-size: 12px;
    }

    .ticket-preview-description {
      color: #605e5c;
      line-height: 1.4;
      margin-bottom: 6px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      font-size: 11px;
    }

    .ticket-preview-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #8a8886;
    }

    .ticket-preview-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      color: #8a8886;
      font-size: 11px;
    }

    .ticket-preview-error {
      color: #d13438;
      font-size: 11px;
      text-align: center;
      padding: 6px;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .chat-selector {
        max-width: 100px;
        font-size: 11px;
      }
      
      .message-bubble {
        font-size: 12px;
        max-width: 85%;
      }
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      color: #8a8886;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <!-- Compact Header -->
  <div class="popout-header">
    <div class="header-title">
      <span>ðŸ’¬</span>
      <span id="current-chat-name">Castle Comms Chat</span>
    </div>
    <select id="chat-selector" class="chat-selector">
      <option value="">Loading chats...</option>
    </select>
  </div>

  <!-- Main Chat Area -->
  <div class="popout-chat">
    <div id="chat-content" class="loading">
      <div>Loading chat...</div>
    </div>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
  
  <!-- Firebase config -->
  <script src="firebase-init.js"></script>
  
  <!-- Main site script (for listUsers function) -->
  <script src="script.js"></script>
  
  <script>
    // Popout Chat Implementation
    let db;
    let currentUser;
    let allUsers = [];
    let currentChat = null;
    let chatListeners = [];
    let lastMessageCount = 0;
    let typingTimer = null;
    let notificationPermission = false;
    let audioContext = null;

    // Get chat ID from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    let initialChatId = urlParams.get('chatId');

    document.addEventListener('DOMContentLoaded', function() {
      // Check authentication
      firebase.auth().onAuthStateChanged(async (user) => {
        if (!user) {
          console.log('User not authenticated, closing popout');
          window.close();
          return;
        }

        currentUser = user;
        
        // Initialize Firebase Firestore
        if (firebase.apps.length > 0) {
          db = firebase.firestore();
          await initializePopoutChat();
        } else {
          console.error('Firebase not initialized');
        }
      });
    });

    // Initialize popout chat
    async function initializePopoutChat() {
      try {
        await loadAllUsers();
        await loadChats();
        setupEventListeners();
        setupNotifications();
        
        // Select initial chat if provided
        if (initialChatId) {
          await selectChat(initialChatId);
        }
        
        console.log('Popout chat initialized successfully');
      } catch (error) {
        console.error('Error initializing popout chat:', error);
      }
    }

    // Load all users (copied from main chat)
    async function loadAllUsers() {
      try {
        // Try to get users from the listUsers function
        if (typeof listUsers === 'function') {
          try {
            const users = await listUsers();
            allUsers = users.map(user => ({
              email: user.email,
              name: user.displayName || extractNameFromEmail(user.email),
              uid: user.uid
            })).filter(user => 
              user.email && 
              user.email !== currentUser.email
            );
            console.log(`Loaded ${allUsers.length} users from Cloud Function`);
            return;
          } catch (error) {
            console.log('Cloud Function not available, trying fallbacks...');
          }
        }

        // Fallbacks (same as main chat)
        try {
          const usersSnapshot = await db.collection('users').get();
          if (!usersSnapshot.empty) {
            allUsers = usersSnapshot.docs.map(doc => {
              const userData = doc.data();
              return {
                uid: doc.id,
                email: userData.email,
                name: userData.displayName || userData.name || extractNameFromEmail(userData.email || '')
              };
            }).filter(user => 
              user.email && user.email !== currentUser.email
            );
            console.log(`Loaded ${allUsers.length} users from Firestore`);
            return;
          }
        } catch (error) {
          console.log('Firestore fallback failed');
        }

        console.warn('No users found');
        allUsers = [];
      } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
      }
    }

    // Load chats and populate selector
    async function loadChats() {
      try {
        const unsubscribe = db.collection('chats')
          .where('participants', 'array-contains', currentUser.email)
          .orderBy('lastMessageAt', 'desc')
          .onSnapshot((snapshot) => {
            populateChatSelector(snapshot.docs);
          });
        
        chatListeners.push(unsubscribe);
      } catch (error) {
        console.error('Error loading chats:', error);
      }
    }

    // Populate chat selector dropdown
    function populateChatSelector(chatDocs) {
      const selector = document.getElementById('chat-selector');
      
      if (chatDocs.length === 0) {
        selector.innerHTML = '<option value="">No chats available</option>';
        return;
      }
      
      const options = chatDocs.map(doc => {
        const data = doc.data();
        return `<option value="${doc.id}" ${currentChat && currentChat.id === doc.id ? 'selected' : ''}>${data.name}</option>`;
      }).join('');
      
      selector.innerHTML = options;
    }

    // Setup event listeners
    function setupEventListeners() {
      // Chat selector change
      document.getElementById('chat-selector').addEventListener('change', (e) => {
        if (e.target.value) {
          selectChat(e.target.value);
        }
      });

      // Listen for messages from parent window
      window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin) return;
        
        if (event.data.type === 'switchChat' && event.data.chatId) {
          selectChat(event.data.chatId);
        }
      });
    }

    // Setup notifications (simplified for popout)
    async function setupNotifications() {
      try {
        if ('Notification' in window) {
          const permission = await Notification.requestPermission();
          notificationPermission = permission === 'granted';
        }
        
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (error) {
          console.log('Audio context not available');
        }
      } catch (error) {
        console.error('Error setting up notifications:', error);
      }
    }

    // Select and display a chat
    async function selectChat(chatId) {
      try {
        const chatDoc = await db.collection('chats').doc(chatId).get();
        if (!chatDoc.exists) {
          console.error('Chat not found');
          return;
        }
        
        const chatData = chatDoc.data();
        currentChat = { id: chatId, ...chatData };
        
        // Update UI
        document.getElementById('current-chat-name').textContent = currentChat.name;
        document.title = `${currentChat.name} - Castle Comms Chat`;
        
        // Update selector
        const selector = document.getElementById('chat-selector');
        selector.value = chatId;
        
        // Load messages
        lastMessageCount = 0;
        displayChatInterface();
        loadChatMessages(chatId);
        
      } catch (error) {
        console.error('Error selecting chat:', error);
      }
    }

    // Display chat interface
    function displayChatInterface() {
      if (!currentChat) return;
      
      const chatContent = document.getElementById('chat-content');
      chatContent.className = '';
      chatContent.innerHTML = `
        <div class="chat-messages" id="chat-messages">
          <div style="text-align: center; padding: 20px; color: #8a8886; font-size: 12px;">
            Loading messages...
          </div>
        </div>
        
        <div class="chat-input-area">
          <div class="typing-indicators" id="typing-indicators"></div>
          <div class="chat-input-container">
            <textarea class="chat-input" id="message-input" placeholder="Type a message..." rows="1"></textarea>
            <button class="send-button" id="send-message-btn" onclick="sendMessage()">Send</button>
          </div>
        </div>
      `;
      
      // Setup message input
      const messageInput = document.getElementById('message-input');
      messageInput.addEventListener('input', handleMessageInput);
      messageInput.addEventListener('keydown', handleMessageInputKeydown);
      messageInput.addEventListener('focus', setupTypingIndicators);
      messageInput.addEventListener('blur', clearTypingIndicator);
    }

    // Load and display chat messages
    async function loadChatMessages(chatId) {
      try {
        // Clean up existing listeners
        if (window.messageListener) {
          window.messageListener();
        }
        
        // Listen for real-time message updates
        window.messageListener = db.collection('chat-messages')
          .where('chatId', '==', chatId)
          .orderBy('timestamp', 'asc')
          .onSnapshot((snapshot) => {
            displayMessages(snapshot.docs);
          });
      } catch (error) {
        console.error('Error loading messages:', error);
      }
    }

    // Display messages
    function displayMessages(messageDocs) {
      const messagesContainer = document.getElementById('chat-messages');
      if (!messagesContainer) return;
      
      if (messageDocs.length === 0) {
        messagesContainer.innerHTML = `
          <div class="chat-empty">
            <div class="chat-empty-icon">ðŸ‘‹</div>
            <div>No messages yet. Start the conversation!</div>
          </div>
        `;
        return;
      }
      
      // Group messages (simplified version)
      const messageGroups = [];
      let currentGroup = null;
      
      messageDocs.forEach(doc => {
        const data = doc.data();
        const isOwn = data.senderEmail === currentUser.email;
        const timestamp = data.timestamp ? data.timestamp.toDate() : new Date();
        
        if (!currentGroup || 
            currentGroup.senderEmail !== data.senderEmail ||
            (timestamp - currentGroup.lastTimestamp) > 5 * 60 * 1000) {
          
          currentGroup = {
            senderEmail: data.senderEmail,
            senderName: data.senderName,
            isOwn: isOwn,
            isSystem: data.type === 'system',
            messages: [],
            lastTimestamp: timestamp
          };
          messageGroups.push(currentGroup);
        }
        
        currentGroup.messages.push({
          id: doc.id,
          message: data.message,
          timestamp: timestamp
        });
        currentGroup.lastTimestamp = timestamp;
      });
      
      // Render messages
      const messagesHTML = messageGroups.map(group => {
        const initials = group.senderName ? group.senderName.substring(0, 2).toUpperCase() : '?';
        const messagesHTML = group.messages.map(msg => 
          `<div class="message-bubble">${enhanceMessageWithTickets(msg.message)}</div>`
        ).join('');
        
        if (group.isSystem) {
          return `
            <div style="text-align: center; margin: 12px 0; color: #8a8886; font-size: 11px;">
              ${enhanceMessageWithTickets(group.messages[0].message)}
            </div>
          `;
        }
        
        return `
          <div class="message-group ${group.isOwn ? 'own' : ''}">
            <div class="message-header ${group.isOwn ? 'own' : ''}">
              <div class="message-avatar">${initials}</div>
              <div class="message-sender">${group.senderName}</div>
              <div class="message-time">${formatTimestamp(group.lastTimestamp)}</div>
            </div>
            ${messagesHTML}
          </div>
        `;
      }).join('');
      
      messagesContainer.innerHTML = messagesHTML;
      
      // Check for new messages and trigger notifications
      const currentMessageCount = messageDocs.length;
      if (currentMessageCount > lastMessageCount && lastMessageCount > 0) {
        const newMessages = messageDocs.slice(lastMessageCount);
        newMessages.forEach(doc => {
          const data = doc.data();
          if (data.senderEmail !== currentUser.email) {
            handleNewMessageNotification(data);
          }
        });
      }
      lastMessageCount = currentMessageCount;
      
      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Mark messages as read
      markMessagesAsRead();
    }

    // Send message
    async function sendMessage() {
      const messageInput = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-message-btn');
      const message = messageInput.value.trim();
      
      if (!message || !currentChat) return;
      
      sendBtn.disabled = true;
      
      try {
        const currentUserName = await getUserDisplayName(currentUser);
        
        await db.collection('chat-messages').add({
          chatId: currentChat.id,
          senderEmail: currentUser.email,
          senderName: currentUserName,
          message: message,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          readBy: [currentUser.email]
        });
        
        // Update chat's last message
        await db.collection('chats').doc(currentChat.id).update({
          lastMessage: message.length > 50 ? message.substring(0, 47) + '...' : message,
          lastMessageSender: currentUserName,
          lastMessageAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Clear input
        messageInput.value = '';
        messageInput.style.height = 'auto';
        
      } catch (error) {
        console.error('Error sending message:', error);
        alert('Failed to send message');
      }
      
      sendBtn.disabled = false;
    }

    // Handle message input
    function handleMessageInput(e) {
      autoResizeTextarea(e);
      handleTypingIndicator();
    }

    // Auto-resize textarea
    function autoResizeTextarea(e) {
      const textarea = e.target;
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 80) + 'px';
    }

    // Handle Enter key
    function handleMessageInputKeydown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    // Simplified typing indicator handling
    function handleTypingIndicator() {
      if (!currentChat || !currentUser) return;
      
      if (typingTimer) {
        clearTimeout(typingTimer);
      }
      
      sendTypingIndicator(true);
      
      typingTimer = setTimeout(() => {
        sendTypingIndicator(false);
      }, 2000);
    }

    function setupTypingIndicators() {
      if (!currentChat) return;
      
      const typingListener = db.collection('chat-typing')
        .where('chatId', '==', currentChat.id)
        .onSnapshot((snapshot) => {
          updateTypingIndicators(snapshot.docs);
        });
      
      chatListeners.push(typingListener);
    }

    function clearTypingIndicator() {
      if (typingTimer) {
        clearTimeout(typingTimer);
      }
      sendTypingIndicator(false);
    }

    async function sendTypingIndicator(isTyping) {
      if (!currentChat || !currentUser) return;
      
      try {
        const typingDocId = `${currentChat.id}_${currentUser.email}`;
        
        if (isTyping) {
          await db.collection('chat-typing').doc(typingDocId).set({
            chatId: currentChat.id,
            userEmail: currentUser.email,
            userName: await getUserDisplayName(currentUser),
            isTyping: true,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        } else {
          await db.collection('chat-typing').doc(typingDocId).delete();
        }
      } catch (error) {
        console.error('Error updating typing indicator:', error);
      }
    }

    function updateTypingIndicators(typingDocs) {
      const typingContainer = document.getElementById('typing-indicators');
      if (!typingContainer) return;
      
      const typingUsers = typingDocs
        .map(doc => doc.data())
        .filter(data => data.userEmail !== currentUser.email && data.isTyping)
        .map(data => data.userName);
      
      if (typingUsers.length === 0) {
        typingContainer.innerHTML = '';
        return;
      }
      
      let typingText = '';
      if (typingUsers.length === 1) {
        typingText = `${typingUsers[0]} is typing`;
      } else {
        typingText = `${typingUsers.length} people are typing`;
      }
      
      typingContainer.innerHTML = `
        <div class="typing-indicator">
          <span>${typingText}</span>
          <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        </div>
      `;
    }

    // Mark messages as read
    async function markMessagesAsRead() {
      if (!currentChat || !currentUser) return;
      
      try {
        const unreadMessages = await db.collection('chat-messages')
          .where('chatId', '==', currentChat.id)
          .where('senderEmail', '!=', currentUser.email)
          .get();
        
        const batch = db.batch();
        let hasUpdates = false;
        
        unreadMessages.docs.forEach(doc => {
          const data = doc.data();
          const readBy = data.readBy || [];
          
          if (!readBy.includes(currentUser.email)) {
            batch.update(doc.ref, {
              readBy: firebase.firestore.FieldValue.arrayUnion(currentUser.email)
            });
            hasUpdates = true;
          }
        });
        
        if (hasUpdates) {
          await batch.commit();
        }
      } catch (error) {
        console.error('Error marking messages as read:', error);
      }
    }

    // Handle new message notifications
    function handleNewMessageNotification(messageData) {
      try {
        // Play sound
        playNotificationSound();
        
        // Update window title
        const originalTitle = document.title;
        document.title = `ðŸ’¬ ${messageData.senderName} - ${currentChat.name}`;
        
        // Reset title after 3 seconds
        setTimeout(() => {
          document.title = originalTitle;
        }, 3000);
        
      } catch (error) {
        console.error('Error handling notification:', error);
      }
    }

    // Play notification sound
    function playNotificationSound() {
      try {
        if (audioContext) {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
          
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.15);
        }
      } catch (error) {
        console.error('Error playing notification sound:', error);
      }
    }

    // Helper functions
    async function getUserDisplayName(user) {
      try {
        if (!user || !window.db) {
          return extractNameFromEmail(user?.email || '');
        }

        const userRef = window.db.ref(`users/${user.uid}`);
        const snapshot = await userRef.once('value');
        const userData = snapshot.val();

        if (userData && userData.name) {
          return userData.name;
        }

        if (user.displayName) {
          return user.displayName;
        }

        return extractNameFromEmail(user.email || '');
      } catch (error) {
        console.error('Error getting user display name:', error);
        return extractNameFromEmail(user?.email || '');
      }
    }

    function extractNameFromEmail(email) {
      if (!email) return 'User';
      const emailName = email.split('@')[0];
      return emailName
        .replace(/[._-]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }

    function formatTimestamp(timestamp) {
      if (!timestamp) return '';
      
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);

      if (diffMins < 1) return 'now';
      if (diffMins < 60) return `${diffMins}m`;
      if (diffHours < 24) return `${diffHours}h`;
      
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    // Ticket linking functionality for popout
    let ticketCache = new Map();
    let activeTicketPreview = null;

    // Detect and enhance ticket references in messages
    function enhanceMessageWithTickets(messageText) {
      if (!messageText) return messageText;
      
      // Patterns to detect: #1234, ticket:1234, TKT-434592, etc.
      const ticketPatterns = [
        /\#(\d{1,6})\b/g,                    // #1234
        /ticket:?\s*(\d{1,6})\b/gi,          // ticket:1234, ticket 1234
        /TKT?-(\d{1,6})\b/gi,                // TKT-1234, TK-1234
        /ticket\s+#?(\d{1,6})\b/gi,          // ticket #1234
        /(TKT-\d{1,6})\b/gi                  // Full TKT-434592 format
      ];
      
      let enhancedText = messageText;
      
      ticketPatterns.forEach(pattern => {
        enhancedText = enhancedText.replace(pattern, (match, ticketId) => {
          return `<span class="ticket-link" data-ticket-id="${ticketId}" onclick="openTicket('${ticketId}')" onmouseenter="showTicketPreview(event, '${ticketId}')" onmouseleave="hideTicketPreview()">${match}</span>`;
        });
      });
      
      return enhancedText;
    }

    // Fetch ticket data from Firestore
    async function fetchTicketData(ticketId) {
      try {
        // Check cache first
        if (ticketCache.has(ticketId)) {
          return ticketCache.get(ticketId);
        }
        
        // Try different ticket ID formats
        const searchFormats = [];
        
        if (ticketId.startsWith('TKT-')) {
          // If already has TKT- prefix, search as-is and without prefix
          searchFormats.push(ticketId);
          searchFormats.push(ticketId.replace('TKT-', ''));
        } else {
          // If just a number, try with and without TKT- prefix
          searchFormats.push(ticketId);
          searchFormats.push(`TKT-${ticketId}`);
        }
        
        // Try each format until we find a match
        for (const searchId of searchFormats) {
          const ticketQuery = await db.collection('tickets')
            .where('ticketId', '==', searchId)
            .limit(1)
            .get();
          
          if (!ticketQuery.empty) {
            const ticketData = ticketQuery.docs[0].data();
            
            // Cache the result for both the original input and found format
            ticketCache.set(ticketId, ticketData);
            ticketCache.set(searchId, ticketData);
            
            return ticketData;
          }
        }
        
        // If not found, cache null to avoid repeated queries
        ticketCache.set(ticketId, null);
        return null;
        
      } catch (error) {
        console.error('Error fetching ticket data:', error);
        return null;
      }
    }

    // Show ticket preview on hover
    async function showTicketPreview(event, ticketId) {
      // Remove any existing preview
      hideTicketPreview();
      
      const ticketLink = event.target;
      const rect = ticketLink.getBoundingClientRect();
      
      // Create preview element
      const preview = document.createElement('div');
      preview.className = 'ticket-preview';
      preview.innerHTML = '<div class="ticket-preview-loading">Loading ticket...</div>';
      
      // Position the preview with screen bounds checking (fixed position for popout window)
      let left = rect.left;
      let top = rect.bottom + 8;
      
      // Check right edge - if preview would go off screen, position it to the left
      if (left + 280 > window.innerWidth) {
        left = Math.max(10, rect.right - 280);
      }
      
      // Check bottom edge - if preview would go off screen, position it above the link
      if (top + 180 > window.innerHeight) {
        top = rect.top - 8 - 180;
      }
      
      // Ensure preview stays within screen bounds
      left = Math.max(10, Math.min(left, window.innerWidth - 290));
      top = Math.max(10, top);
      
      preview.style.left = `${left}px`;
      preview.style.top = `${top}px`;
      
      document.body.appendChild(preview);
      activeTicketPreview = preview;
      
      // Show with animation
      setTimeout(() => preview.classList.add('show'), 10);
      
      try {
        // Fetch ticket data
        const ticketData = await fetchTicketData(ticketId);
        
        if (ticketData) {
          preview.innerHTML = `
            <div class="ticket-preview-header">
              <span class="ticket-preview-id">#${ticketData.ticketId}</span>
              <span class="ticket-preview-status ${ticketData.status}">${ticketData.status}</span>
            </div>
            <div class="ticket-preview-title">${ticketData.title}</div>
            <div class="ticket-preview-description">${ticketData.description}</div>
            <div class="ticket-preview-meta">
              <span>Assigned: ${ticketData.assignedTo.name}</span>
              <span>Created: ${formatTimestamp(ticketData.createdAt)}</span>
            </div>
          `;
        } else {
          preview.innerHTML = '<div class="ticket-preview-error">Ticket #' + ticketId + ' not found</div>';
        }
      } catch (error) {
        preview.innerHTML = '<div class="ticket-preview-error">Error loading ticket</div>';
      }
    }

    // Hide ticket preview
    function hideTicketPreview() {
      if (activeTicketPreview) {
        activeTicketPreview.remove();
        activeTicketPreview = null;
      }
    }

    // Open ticket in parent window - goes directly to internal tickets section
    function openTicket(ticketId) {
      if (window.opener) {
        window.opener.open(`tickets.html#ticket-${ticketId}`, '_blank');
      } else {
        window.open(`tickets.html#ticket-${ticketId}`, '_blank');
      }
    }

    // Cleanup when window closes
    window.addEventListener('beforeunload', () => {
      // Clean up listeners
      chatListeners.forEach(unsubscribe => unsubscribe());
      if (window.messageListener) {
        window.messageListener();
      }
      // Clear typing indicator
      clearTypingIndicator();
    });
  </script>
</body>
</html>