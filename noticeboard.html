<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Noticeboard - Castle Comms</title>
  
  <!-- Security Headers -->
  <meta http-equiv="X-Frame-Options" content="SAMEORIGIN">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  
  <link rel="stylesheet" href="style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Caveat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    .noticeboard-container {
      max-width: 1000px;
      margin: 2rem auto;
      padding: 2rem;
      position: relative;
      min-height: 80vh;
    }

    .whiteboard {
      background: #ffffff;
      border: 20px solid #8b4513;
      border-radius: 15px;
      position: relative;
      min-height: 600px;
      box-shadow: 
        0 0 20px rgba(0,0,0,0.3),
        inset 0 0 50px rgba(0,0,0,0.05);
      background-image: 
        radial-gradient(circle at 20% 20%, rgba(0,0,0,0.02) 1px, transparent 1px),
        radial-gradient(circle at 80% 80%, rgba(0,0,0,0.01) 1px, transparent 1px);
      background-size: 40px 40px, 25px 25px;
      cursor: crosshair;
    }
    
    .whiteboard canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      border-radius: inherit;
    }

    .whiteboard::before {
      content: '';
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 30px;
      background: #2c3e50;
      border-radius: 10px;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
    }

    .input-section {
      background: rgba(255,255,255,0.95);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      max-width: 500px;
      margin: 0 auto 20px auto;
      border: 2px solid #dee2e6;
      box-sizing: border-box;
    }

    .note-input {
      width: 100%;
      min-height: 80px;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      font-family: 'Kalam', cursive;
      font-size: 14px;
      resize: vertical;
      margin-bottom: 10px;
      box-sizing: border-box;
    }

    .add-note-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Kalam', cursive;
      font-weight: bold;
      transition: background 0.3s ease;
    }

    .add-note-btn:hover {
      background: #218838;
    }

    .drawing {
      position: absolute;
      cursor: pointer;
      transform: rotate(-2deg);
      transition: transform 0.3s ease;
      user-select: none;
    }

    .drawing:nth-child(odd) {
      transform: rotate(1deg);
    }

    .drawing:nth-child(3n) {
      transform: rotate(-1deg);
    }

    .drawing:hover {
      transform: rotate(0deg) scale(1.05);
      z-index: 10;
    }

    .drawing.being-erased {
      opacity: 0.3;
      transform: scale(0.8);
    }

    .drawing.admin-draggable {
      cursor: move;
      border: 2px dashed rgba(102, 126, 234, 0.5);
      z-index: 10; /* Above canvas but below dragged state */
    }

    .drawing.admin-draggable:hover {
      border-color: rgba(102, 126, 234, 0.8);
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
    }

    .drawing.being-dragged {
      opacity: 0.8;
      z-index: 1000;
      transform: scale(1.05);
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.3));
      pointer-events: none; /* Prevent interference during drag */
    }

    .eraser {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 180px;
      height: 120px;
      background: url('eraser.png') no-repeat center center;
      background-size: contain;
      cursor: grab;
      transition: all 0.3s ease;
      z-index: 100;
    }

    .eraser:hover {
      transform: scale(1.1);
    }

    .eraser.dragging {
      cursor: grabbing;
      transform: scale(1.2);
      z-index: 1000;
    }


    .note-counter {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(52, 58, 64, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-family: 'Kalam', cursive;
      font-size: 14px;
      backdrop-filter: blur(10px);
    }

    @media screen and (max-width: 768px) {
      .noticeboard-container {
        margin: 1rem;
        padding: 1rem;
      }
      
      .input-section {
        position: relative;
        max-width: 100%;
        margin-bottom: 20px;
      }
      
      .whiteboard {
        min-height: 500px;
      }
      
      .note {
        font-size: 16px;
        max-width: 200px;
      }
    }
  </style>
</head>
<body>

<!-- Background Slideshow -->
<div class="background-slideshow" id="background-slideshow">
  <!-- Images will be injected by JavaScript -->
</div>
  
<header>
  <button id="menu-toggle" class="hamburger">&#9776;</button>
  <h1>Castle Comms</h1>
</header>

<div id="notification-bell" class="notification-bell hidden">
  ðŸ”” <span id="notification-count" class="count-badge">0</span>
</div>

<div id="sidebar-container"></div>

<main id="main">
  <div class="noticeboard-container">
    <!-- Drawing Tools -->
    <div class="drawing-tools" style="position: fixed; top: 80px; left: 20px; z-index: 1001; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); backdrop-filter: blur(10px);">
      <h4 style="margin: 0 0 10px 0; font-family: 'Kalam', cursive; color: #2c3e50; text-align: center;">Drawing Tools</h4>
      
      <div style="display: flex; flex-direction: column; gap: 10px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-family: 'Kalam', cursive; font-size: 12px; width: 40px;">Color:</label>
          <input type="color" id="colorPicker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <label style="font-family: 'Kalam', cursive; font-size: 12px; width: 40px;">Size:</label>
          <input type="range" id="brushSize" min="2" max="15" value="5" style="width: 80px;">
          <span id="brushSizeValue" style="font-family: 'Kalam', cursive; font-size: 12px; width: 30px;">5px</span>
        </div>
        <button id="clearDrawing" style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Kalam', cursive; font-size: 12px; width: 100%;">Clear All</button>
        <button id="finishDrawing" class="add-note-btn" style="width: 100%; margin: 0; padding: 8px 12px; font-size: 12px;">Finish Drawing</button>
      </div>
    </div>
    
    <div class="whiteboard" id="whiteboard">
      <canvas id="drawingCanvas" style="position: absolute; top: 0; left: 0; z-index: 1;"></canvas>
      
      <div class="note-counter" id="noteCounter">
        Drawings: 0
      </div>
      
      <div class="eraser" id="eraser" title="Drag to erase drawings">
      </div>
    </div>
  </div>
</main>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<!-- Firebase config -->
<script src="firebase-init.js"></script>

<!-- Shared components -->
<script src="shared-components.js"></script>

<!-- Drawing Noticeboard Logic -->
<script>
let db;
let drawings = [];
let isDragging = false;
let dragElement = null;

// Drawing variables
let canvas, ctx;
let isDrawing = false;
let currentColor = '#000000';
let currentSize = 3;

// Admin drag variables
let isAdmin = false;
let isDraggingDrawing = false;
let draggedDrawing = null;
let dragStartX = 0;
let dragStartY = 0;
let drawingStartX = 0;
let drawingStartY = 0;

document.addEventListener('DOMContentLoaded', function() {
  // Check authentication first
  firebase.auth().onAuthStateChanged(async (user) => {
    if (!user) {
      console.log('User not authenticated, redirecting to login');
      window.location.href = 'index.html';
      return;
    }

    // Initialize Firebase Firestore only if authenticated
    if (firebase.apps.length > 0) {
      db = firebase.firestore();
      
      // Check if user is admin
      if (window.authUtils) {
        isAdmin = await window.authUtils.isAdmin(user);
        console.log('Admin status:', isAdmin);
      }
      
      await loadDrawings();
      
      // Enable admin drag functionality for existing drawings
      if (isAdmin) {
        enableAdminDragForExistingDrawings();
      }
    } else {
      console.error('Firebase not initialized');
    }

    // Initialize drawing canvas
    initializeDrawing();
    
    // Drawing tools are initialized in initializeDrawing function
    
    // Eraser functionality
    const eraser = document.getElementById('eraser');
    eraser.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    
    // Touch events for mobile
    eraser.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', endDrag);
  });
});

function initializeDrawing() {
  canvas = document.getElementById('drawingCanvas');
  ctx = canvas.getContext('2d');
  
  // Size canvas to match whiteboard
  const whiteboard = document.getElementById('whiteboard');
  const whiteboardRect = whiteboard.getBoundingClientRect();
  canvas.width = whiteboard.clientWidth;
  canvas.height = whiteboard.clientHeight;
  
  // Set drawing properties
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  // Drawing event listeners
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);
  
  // Touch events for mobile
  canvas.addEventListener('touchstart', handleTouch);
  canvas.addEventListener('touchmove', handleTouch);
  canvas.addEventListener('touchend', stopDrawing);
  
  // Tool controls
  const colorPicker = document.getElementById('colorPicker');
  const brushSize = document.getElementById('brushSize');
  const brushSizeValue = document.getElementById('brushSizeValue');
  const clearCanvas = document.getElementById('clearDrawing');
  const finishDrawing = document.getElementById('finishDrawing');
  
  colorPicker.addEventListener('change', (e) => {
    currentColor = e.target.value;
  });
  
  brushSize.addEventListener('input', (e) => {
    currentSize = e.target.value;
    brushSizeValue.textContent = currentSize + 'px';
  });
  
  clearCanvas.addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
  
  finishDrawing.addEventListener('click', saveDrawing);
}

function startDrawing(e) {
  // Check if we're clicking on an existing drawing (for admin drag)
  if (isAdmin && isClickingOnDrawing(e)) {
    return; // Don't start drawing if clicking on an existing drawing
  }
  
  isDrawing = true;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  ctx.beginPath();
  ctx.moveTo(x, y);
}

// Helper function to check if click is on an existing drawing
function isClickingOnDrawing(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Get all drawings
  const drawings = document.querySelectorAll('.drawing');
  
  for (let drawing of drawings) {
    const drawingRect = drawing.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Convert drawing position to canvas coordinates
    const drawingX = drawingRect.left - canvasRect.left;
    const drawingY = drawingRect.top - canvasRect.top;
    const drawingWidth = drawingRect.width;
    const drawingHeight = drawingRect.height;
    
    // Check if click is within drawing bounds
    if (x >= drawingX && x <= drawingX + drawingWidth &&
        y >= drawingY && y <= drawingY + drawingHeight) {
      return true;
    }
  }
  
  return false;
}

function draw(e) {
  if (!isDrawing) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  ctx.lineWidth = currentSize;
  ctx.strokeStyle = currentColor;
  ctx.lineTo(x, y);
  ctx.stroke();
}

function stopDrawing() {
  isDrawing = false;
}

function handleTouch(e) {
  e.preventDefault();
  const touch = e.touches[0];
  const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                   e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
}

async function saveDrawing() {
  // Check if canvas has content by checking if it's all white/transparent
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const pixels = imageData.data;
  let hasContent = false;
  
  for (let i = 0; i < pixels.length; i += 4) {
    if (pixels[i + 3] > 0) { // Check alpha channel
      hasContent = true;
      break;
    }
  }
  
  if (!hasContent) {
    alert('Please draw something first!');
    return;
  }
  
  const drawingData = {
    imageData: canvas.toDataURL('image/png'),
    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
    position: getRandomPosition()
  };
  
  try {
    const docRef = await db.collection('drawings').add(drawingData);
    drawingData.id = docRef.id;
    drawingData.timestamp = new Date(); // For immediate display
    
    createDrawingElement(drawingData);
    // Clear canvas after saving
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateDrawingCounter();
  } catch (error) {
    console.error('Error saving drawing:', error);
    alert('Failed to save drawing. Please try again.');
  }
}

function createDrawingElement(drawingData) {
  const whiteboard = document.getElementById('whiteboard');
  const drawingElement = document.createElement('img');
  drawingElement.className = 'drawing';
  drawingElement.dataset.id = drawingData.id;
  drawingElement.src = drawingData.imageData;
  
  // Scale the image for display on whiteboard
  drawingElement.style.maxWidth = '400px';
  drawingElement.style.maxHeight = '300px';
  drawingElement.style.left = drawingData.position.x + 'px';
  drawingElement.style.top = drawingData.position.y + 'px';
  
  // Add some random rotation for natural look
  const rotation = (Math.random() - 0.5) * 6; // -3 to +3 degrees
  drawingElement.style.transform = `rotate(${rotation}deg)`;
  
  // Add admin drag functionality
  if (isAdmin) {
    drawingElement.classList.add('admin-draggable');
    drawingElement.addEventListener('mousedown', startDrawingDrag);
    drawingElement.addEventListener('touchstart', startDrawingDrag);
  }
  
  whiteboard.appendChild(drawingElement);
  drawings.push(drawingData);
  
  // Animate in
  setTimeout(() => {
    drawingElement.style.opacity = '1';
    drawingElement.style.transform += ' scale(1)';
  }, 100);
}

function getRandomPosition() {
  const whiteboard = document.getElementById('whiteboard');
  const rect = whiteboard.getBoundingClientRect();
  
  // Drawing dimensions (doubled from original)
  const drawingWidth = 400;
  const drawingHeight = 300;
  
  // Account for drawing size, note counter, and eraser areas
  const minX = 30;
  const maxX = Math.max(minX + 50, rect.width - drawingWidth - 30);
  const minY = 60; // Space for note counter
  const maxY = Math.max(minY + 50, rect.height - drawingHeight - 120); // Space for eraser (120px height)
  
  return {
    x: Math.random() * (maxX - minX) + minX,
    y: Math.random() * (maxY - minY) + minY
  };
}

async function loadDrawings() {
  try {
    const snapshot = await db.collection('drawings').orderBy('timestamp', 'desc').get();
    snapshot.forEach(doc => {
      const drawingData = { id: doc.id, ...doc.data() };
      createDrawingElement(drawingData);
    });
    updateDrawingCounter();
  } catch (error) {
    console.error('Error loading drawings:', error);
  }
}

// Function to enable admin mode on existing drawings
function enableAdminDragForExistingDrawings() {
  if (!isAdmin) return;
  
  const existingDrawings = document.querySelectorAll('.drawing');
  existingDrawings.forEach(drawing => {
    if (!drawing.classList.contains('admin-draggable')) {
      drawing.classList.add('admin-draggable');
      drawing.addEventListener('mousedown', startDrawingDrag);
      drawing.addEventListener('touchstart', startDrawingDrag);
    }
  });
}

function startDrag(e) {
  isDragging = true;
  dragElement = e.target;
  dragElement.classList.add('dragging');
  
  e.preventDefault();
}

function drag(e) {
  if (!isDragging || !dragElement) return;
  
  const clientX = e.clientX || (e.touches && e.touches[0].clientX);
  const clientY = e.clientY || (e.touches && e.touches[0].clientY);
  
  if (!clientX || !clientY) return;
  
  // Get whiteboard container position
  const whiteboard = document.getElementById('whiteboard');
  const whiteboardRect = whiteboard.getBoundingClientRect();
  
  // Calculate position relative to whiteboard
  const relativeX = clientX - whiteboardRect.left - 40;
  const relativeY = clientY - whiteboardRect.top - 20;
  
  // Move eraser relative to whiteboard
  dragElement.style.position = 'absolute';
  dragElement.style.left = relativeX + 'px';
  dragElement.style.top = relativeY + 'px';
  
  
  // Check for collision with drawings
  const drawings = document.querySelectorAll('.drawing');
  drawings.forEach(drawing => {
    const rect = drawing.getBoundingClientRect();
    const eraserRect = {
      left: clientX - 20,
      right: clientX + 20,
      top: clientY - 15,
      bottom: clientY + 15
    };
    
    if (isColliding(eraserRect, rect)) {
      eraseDrawing(drawing);
    }
  });
  
  e.preventDefault();
}

function endDrag() {
  if (dragElement) {
    dragElement.classList.remove('dragging');
    // Reset eraser position to original bottom-right
    dragElement.style.position = 'absolute';
    dragElement.style.left = '';
    dragElement.style.top = '';
    dragElement.style.bottom = '30px';
    dragElement.style.right = '30px';
  }
  isDragging = false;
  dragElement = null;
}


function isColliding(rect1, rect2) {
  return !(rect1.right < rect2.left || 
           rect1.left > rect2.right || 
           rect1.bottom < rect2.top || 
           rect1.top > rect2.bottom);
}

async function eraseDrawing(drawingElement) {
  const drawingId = drawingElement.dataset.id;
  
  // Add erasing animation
  drawingElement.classList.add('being-erased');
  
  try {
    // Delete from Firebase
    await db.collection('drawings').doc(drawingId).delete();
    
    // Remove from DOM after animation
    setTimeout(() => {
      if (drawingElement.parentNode) {
        drawingElement.parentNode.removeChild(drawingElement);
        drawings = drawings.filter(drawing => drawing.id !== drawingId);
        updateDrawingCounter();
      }
    }, 300);
    
  } catch (error) {
    console.error('Error deleting drawing:', error);
    drawingElement.classList.remove('being-erased');
  }
}

function updateDrawingCounter() {
  const counter = document.getElementById('noteCounter');
  const count = document.querySelectorAll('.drawing').length;
  counter.textContent = `Drawings: ${count}`;
}

// Admin drawing drag functionality
function startDrawingDrag(e) {
  if (!isAdmin || isDraggingDrawing) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  // Prevent any drawing from starting
  if (isDrawing) {
    isDrawing = false;
  }
  
  isDraggingDrawing = true;
  draggedDrawing = e.target;
  
  const clientX = e.clientX || (e.touches && e.touches[0].clientX);
  const clientY = e.clientY || (e.touches && e.touches[0].clientY);
  
  dragStartX = clientX;
  dragStartY = clientY;
  
  const rect = draggedDrawing.getBoundingClientRect();
  drawingStartX = rect.left;
  drawingStartY = rect.top;
  
  draggedDrawing.classList.add('being-dragged');
  
  // Add global event listeners
  document.addEventListener('mousemove', dragDrawing);
  document.addEventListener('mouseup', endDrawingDrag);
  document.addEventListener('touchmove', dragDrawing);
  document.addEventListener('touchend', endDrawingDrag);
}

function dragDrawing(e) {
  if (!isDraggingDrawing || !draggedDrawing) return;
  
  e.preventDefault();
  
  const clientX = e.clientX || (e.touches && e.touches[0].clientX);
  const clientY = e.clientY || (e.touches && e.touches[0].clientY);
  
  const deltaX = clientX - dragStartX;
  const deltaY = clientY - dragStartY;
  
  const newLeft = drawingStartX + deltaX;
  const newTop = drawingStartY + deltaY;
  
  // Get whiteboard boundaries
  const whiteboard = document.getElementById('whiteboard');
  const whiteboardRect = whiteboard.getBoundingClientRect();
  
  // Calculate relative position within whiteboard
  const relativeX = newLeft - whiteboardRect.left;
  const relativeY = newTop - whiteboardRect.top;
  
  // Constrain within boundaries (accounting for drawing size)
  const drawingWidth = 400;
  const drawingHeight = 300;
  const minX = 0;
  const maxX = whiteboardRect.width - drawingWidth;
  const minY = 0;
  const maxY = whiteboardRect.height - drawingHeight;
  
  const constrainedX = Math.max(minX, Math.min(maxX, relativeX));
  const constrainedY = Math.max(minY, Math.min(maxY, relativeY));
  
  draggedDrawing.style.left = constrainedX + 'px';
  draggedDrawing.style.top = constrainedY + 'px';
}

function endDrawingDrag(e) {
  if (!isDraggingDrawing || !draggedDrawing) return;
  
  e.preventDefault();
  
  // Remove global event listeners
  document.removeEventListener('mousemove', dragDrawing);
  document.removeEventListener('mouseup', endDrawingDrag);
  document.removeEventListener('touchmove', dragDrawing);
  document.removeEventListener('touchend', endDrawingDrag);
  
  draggedDrawing.classList.remove('being-dragged');
  
  // Update position in Firebase
  updateDrawingPosition(draggedDrawing);
  
  // Reset drag state
  isDraggingDrawing = false;
  draggedDrawing = null;
}

async function updateDrawingPosition(drawingElement) {
  try {
    const drawingId = drawingElement.dataset.id;
    const newX = parseInt(drawingElement.style.left);
    const newY = parseInt(drawingElement.style.top);
    
    await db.collection('drawings').doc(drawingId).update({
      position: {
        x: newX,
        y: newY
      }
    });
    
    console.log('Drawing position updated:', drawingId, { x: newX, y: newY });
    
  } catch (error) {
    console.error('Error updating drawing position:', error);
    // Could show a toast notification here
  }
}
</script>

<!-- Site scripts -->
<script src="script.js"></script>
</body>
</html>