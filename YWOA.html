<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your World, Our Art - Visualize Art in Your Space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Import DIN Font */
        @font-face {
            font-family: 'DIN Light Alternate';
            src: url('DIN LightAlternate.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root {
            --primary-color: #d8d1c5;
            --secondary-color: #45494e;
            --tertiary-color: #6a6e73;
            --accent-color: #c5bdb1;
            --text-dark: #45494e;
            --text-light: #6a6e73;
            --text-muted: #999ea3;
            --background-overlay: rgba(216, 209, 197, 0.95);
            --card-background: #F0EDE9;
            --shadow-subtle: 0 2px 8px rgba(69, 73, 78, 0.08);
            --shadow-light: 0 4px 12px rgba(69, 73, 78, 0.12);
            --shadow-medium: 0 8px 20px rgba(69, 73, 78, 0.15);
            --shadow-heavy: 0 12px 30px rgba(69, 73, 78, 0.2);
            --border-radius: 8px;
            --border-radius-large: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --font-primary: 'DIN Light Alternate', 'DIN 2014', 'DIN', 'Helvetica Neue', Arial, sans-serif;
            --letter-spacing-headers: 0.025em;
            --letter-spacing-normal: 0;
            --primary-gradient: linear-gradient(135deg, #45494e 0%, #6a6e73 100%);
        }

        body {
            font-family: var(--font-primary);
            background: linear-gradient(135deg, var(--primary-color) 0%, #e5ded2 100%);
            min-height: 100vh;
            padding: 20px;
            font-weight: 300;
            color: var(--text-dark);
            letter-spacing: var(--letter-spacing-normal);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: var(--primary-gradient);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 500;
            font-family: var(--font-primary);
            letter-spacing: var(--letter-spacing-headers);
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            display: flex;
            min-height: 700px;
        }

        .controls {
            width: 350px;
            background: var(--card-background);
            padding: 30px;
            border-right: 1px solid rgba(216, 209, 197, 0.3);
        }

        .control-group {
            margin-bottom: 30px;
        }

        .control-group h3 {
            color: var(--secondary-color);
            margin-bottom: 15px;
            font-size: 1.1rem;
            font-family: var(--font-primary);
            font-weight: 500;
            letter-spacing: var(--letter-spacing-headers);
        }

        .upload-area {
            border: 2px dashed var(--accent-color);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
            background: white;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            box-shadow: var(--shadow-subtle);
        }

        .upload-area:hover {
            border-color: var(--secondary-color);
            background: var(--card-background);
            box-shadow: var(--shadow-light);
        }

        .upload-area.dragover {
            border-color: var(--tertiary-color);
            background: var(--background-overlay);
        }

        .upload-area input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .upload-preview {
            max-width: 100%;
            max-height: 80px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .measurement-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .measurement-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            font-family: var(--font-primary);
            background: white;
        }

        .measurement-input select {
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            background: white;
            font-family: var(--font-primary);
        }

        .btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-family: var(--font-primary);
            font-weight: 400;
            transition: var(--transition);
            width: 100%;
            margin-top: 10px;
            box-shadow: var(--shadow-light);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-subtle);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--card-background);
            overflow: hidden;
        }

        #mainCanvas {
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(69, 73, 78, 0.9);
            color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            max-width: 300px;
            font-size: 14px;
            line-height: 1.4;
            font-family: var(--font-primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-light);
        }

        .point-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--secondary-color);
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: var(--shadow-light);
        }

        .measurement-line {
            position: absolute;
            height: 2px;
            background: var(--secondary-color);
            transform-origin: left center;
            z-index: 9;
        }

        .measurement-text {
            position: absolute;
            background: var(--secondary-color);
            color: white;
            padding: 4px 8px;
            border-radius: var(--border-radius);
            font-size: 12px;
            font-weight: 500;
            font-family: var(--font-primary);
            transform: translate(-50%, -50%);
            z-index: 11;
        }

        .artwork-container {
            position: absolute;
            cursor: move;
            z-index: 8;
        }

        .artwork-shadow {
            position: absolute;
            background: rgba(0, 0, 0, 0.3);
            filter: blur(3px);
            transform: skewX(-5deg) translateX(3px) translateY(3px);
            z-index: 7;
        }

        .export-section {
            padding: 20px 30px;
            background: var(--card-background);
            border-top: 1px solid rgba(216, 209, 197, 0.3);
        }

        .export-options {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 14px;
        }

        .status.success {
            background: rgba(216, 209, 197, 0.2);
            color: var(--secondary-color);
            border: 1px solid var(--accent-color);
        }

        .status.error {
            background: rgba(106, 110, 115, 0.1);
            color: var(--secondary-color);
            border: 1px solid var(--tertiary-color);
        }

        .status.info {
            background: var(--background-overlay);
            color: var(--text-dark);
            border: 1px solid var(--accent-color);
        }

        .rotation-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .rotation-control input[type="range"] {
            flex: 1;
            height: 6px;
            background: var(--accent-color);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .rotation-control input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--secondary-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-light);
        }

        .rotation-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--secondary-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-light);
        }

        .rotation-control span {
            min-width: 35px;
            text-align: center;
            font-weight: 500;
            color: var(--secondary-color);
            font-family: var(--font-primary);
        }

        .rotation-control label {
            min-width: 60px;
            font-weight: 500;
            color: var(--secondary-color);
            font-family: var(--font-primary);
            font-size: 14px;
        }

        .artwork-element {
            position: absolute;
            background-size: cover;
            background-position: center;
            cursor: move;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transform-origin: center center;
        }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Your World, Our Art</h1>
            <p>Visualize artwork in your space with realistic scaling and positioning</p>
        </div>

        <div class="main-content">
            <div class="controls">
                <div class="control-group">
                    <h3>1. Upload Room Image</h3>
                    <div class="upload-area" id="roomUpload">
                        <input type="file" id="roomFile" accept="image/*">
                        <p>üì∏ Drop room image here or click to browse</p>
                        <img id="roomPreview" class="upload-preview" style="display: none;">
                    </div>
                </div>

                <div class="control-group">
                    <h3>2. Upload Artwork</h3>
                    <div class="upload-area" id="artworkUpload">
                        <input type="file" id="artworkFile" accept="image/*">
                        <p>üé® Drop artwork image here or click to browse</p>
                        <img id="artworkPreview" class="upload-preview" style="display: none;">
                    </div>
                </div>

                <div class="control-group">
                    <h3>3. Set Room Scale</h3>
                    <p style="font-size: 12px; color: #666; margin-bottom: 10px;">
                        Click two points in your room image and enter the real distance between them
                    </p>
                    <div class="measurement-input">
                        <input type="number" id="realDistance" placeholder="Distance" step="0.1" min="0">
                        <select id="distanceUnit">
                            <option value="ft">ft</option>
                            <option value="m">m</option>
                            <option value="cm">cm</option>
                            <option value="in">in</option>
                        </select>
                    </div>
                    <button class="btn" id="clearPoints">Clear Points</button>
                </div>

                <div class="control-group">
                    <h3>4. Artwork Size</h3>
                    <div class="measurement-input">
                        <input type="number" id="artworkWidth" placeholder="Width" step="0.1" min="0">
                        <select id="artworkUnit">
                            <option value="ft">ft</option>
                            <option value="m">m</option>
                            <option value="cm">cm</option>
                            <option value="in">in</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>5. Artwork Rotation</h3>
                    <div class="rotation-control">
                        <label>X-axis:</label>
                        <input type="range" id="rotationXSlider" min="-90" max="90" value="0" step="1">
                        <span id="rotationXValue">0¬∞</span>
                    </div>
                    <div class="rotation-control">
                        <label>Y-axis:</label>
                        <input type="range" id="rotationYSlider" min="-90" max="90" value="0" step="1">
                        <span id="rotationYValue">0¬∞</span>
                    </div>
                    <div class="rotation-control">
                        <label>Z-axis:</label>
                        <input type="range" id="rotationZSlider" min="-90" max="90" value="0" step="1">
                        <span id="rotationZValue">0¬∞</span>
                    </div>
                    <button class="btn" id="resetRotation">Reset All Rotation</button>
                </div>

                <div id="statusMessages"></div>
            </div>

            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
                <canvas id="webglCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            </div>
        </div>

        <div class="export-section">
            <div class="export-options">
                <button class="btn" id="exportJPG">üì∏ Export as JPG</button>
                <button class="btn" id="exportScreenshot">üì∏ Quick Screenshot (exact)</button>
                <button class="btn" id="exportPNG">üñºÔ∏è Export as PNG</button>
                <button class="btn" id="shareImage">üì§ Share Image</button>
            </div>
        </div>
    </div>

    <script>
        class YWOAApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // WebGL setup
                this.webglCanvas = document.getElementById('webglCanvas');
                this.gl = this.webglCanvas.getContext('webgl') || this.webglCanvas.getContext('experimental-webgl');
                
                this.roomImage = null;
                this.artworkImage = null;
                this.artworkTexture = null; // WebGL texture for artwork
                this.roomImageDisplayed = null;
                this.scalePoints = [];
                this.realDistance = 0;
                this.distanceUnit = 'ft';
                this.artworkWidth = 0;
                this.artworkUnit = 'ft';
                this.artworkPosition = { x: 0, y: 0 };
                this.artworkSize = { width: 0, height: 0 };
                this.artworkRotation = { x: 0, y: 0, z: 0 }; // Rotation in degrees for each axis
                this.artworkElement = null; // HTML element for CSS transforms
                this.pixelsPerUnit = 1;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };

                this.initializeCanvas();
                this.initializeWebGL();
                this.bindEvents();
                this.showStatus('Welcome! Start by uploading a room image.', 'info');
            }

            initializeCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Set canvas internal resolution
                this.canvas.width = containerWidth;
                this.canvas.height = containerHeight;
                
                // Set canvas display size to match internal resolution
                this.canvas.style.width = containerWidth + 'px';
                this.canvas.style.height = containerHeight + 'px';
                
                // Resize WebGL canvas to match
                if (this.webglCanvas) {
                    this.webglCanvas.width = containerWidth;
                    this.webglCanvas.height = containerHeight;
                    this.webglCanvas.style.width = containerWidth + 'px';
                    this.webglCanvas.style.height = containerHeight + 'px';
                    
                    if (this.gl) {
                        this.gl.viewport(0, 0, containerWidth, containerHeight);
                    }
                }
                
                this.redraw();
            }

            initializeWebGL() {
                if (!this.gl) {
                    console.warn('WebGL not supported, falling back to 2D rendering');
                    return;
                }

                // Vertex shader for 3D plane
                const vertexShaderSource = `
                    attribute vec3 a_position;
                    attribute vec2 a_texCoord;
                    
                    uniform mat4 u_matrix;
                    
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = u_matrix * vec4(a_position, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                // Fragment shader for textured plane
                const fragmentShaderSource = `
                    precision mediump float;
                    
                    uniform sampler2D u_texture;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_FragColor = texture2D(u_texture, v_texCoord);
                    }
                `;

                // Create and compile shaders
                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                
                if (!this.shaderProgram) {
                    console.warn('Failed to create WebGL shader program');
                    return;
                }

                // Get attribute and uniform locations
                this.programInfo = {
                    attribLocations: {
                        position: this.gl.getAttribLocation(this.shaderProgram, 'a_position'),
                        texCoord: this.gl.getAttribLocation(this.shaderProgram, 'a_texCoord'),
                    },
                    uniformLocations: {
                        matrix: this.gl.getUniformLocation(this.shaderProgram, 'u_matrix'),
                        texture: this.gl.getUniformLocation(this.shaderProgram, 'u_texture'),
                    },
                };

                // Create plane geometry
                this.createPlaneGeometry();

                // Enable blending for transparency
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.enable(this.gl.DEPTH_TEST);
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const gl = this.gl;
                
                // Create vertex shader
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vertexSource);
                gl.compileShader(vertexShader);
                
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    console.error('Vertex shader compilation error:', gl.getShaderInfoLog(vertexShader));
                    return null;
                }

                // Create fragment shader
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fragmentSource);
                gl.compileShader(fragmentShader);
                
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    console.error('Fragment shader compilation error:', gl.getShaderInfoLog(fragmentShader));
                    return null;
                }

                // Create program
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    return null;
                }

                return program;
            }

            createPlaneGeometry() {
                const gl = this.gl;
                
                // Create a quad (two triangles) for the artwork plane
                const positions = [
                    -1, -1, 0,  // bottom left
                     1, -1, 0,  // bottom right
                    -1,  1, 0,  // top left
                     1,  1, 0,  // top right
                ];

                const texCoords = [
                    0, 1,  // bottom left
                    1, 1,  // bottom right
                    0, 0,  // top left
                    1, 0,  // top right
                ];

                const indices = [
                    0, 1, 2,  // first triangle
                    2, 1, 3,  // second triangle
                ];

                // Create position buffer
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                // Create texture coordinate buffer
                this.texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

                // Create index buffer
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

                this.indexCount = indices.length;
            }

            // Matrix math utilities for 3D transformations
            createMatrix() {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            }

            multiplyMatrices(a, b) {
                const result = [];
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            }

            translationMatrix(x, y, z) {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    x, y, z, 1
                ];
            }

            rotationXMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ];
            }

            rotationYMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ];
            }

            rotationZMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            }

            scaleMatrix(x, y, z) {
                return [
                    x, 0, 0, 0,
                    0, y, 0, 0,
                    0, 0, z, 0,
                    0, 0, 0, 1
                ];
            }

            orthographicMatrix(left, right, bottom, top, near, far) {
                return [
                    2 / (right - left), 0, 0, 0,
                    0, 2 / (top - bottom), 0, 0,
                    0, 0, 2 / (near - far), 0,
                    (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1
                ];
            }

            createArtworkTexture(image) {
                if (!this.gl || !image) return null;

                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                // Upload image to texture
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                
                // Set texture parameters
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                return texture;
            }

            bindEvents() {
                // File uploads
                document.getElementById('roomFile').addEventListener('change', (e) => this.handleRoomUpload(e));
                document.getElementById('artworkFile').addEventListener('change', (e) => this.handleArtworkUpload(e));

                // Drag and drop
                this.setupDragDrop('roomUpload', 'roomFile');
                this.setupDragDrop('artworkUpload', 'artworkFile');

                // Canvas interactions
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Controls
                document.getElementById('realDistance').addEventListener('input', (e) => this.updateScale());
                document.getElementById('distanceUnit').addEventListener('change', (e) => this.updateScale());
                document.getElementById('artworkWidth').addEventListener('input', (e) => this.updateArtworkSize());
                document.getElementById('artworkUnit').addEventListener('change', (e) => this.updateArtworkSize());
                document.getElementById('clearPoints').addEventListener('click', () => this.clearScalePoints());
                document.getElementById('rotationXSlider').addEventListener('input', (e) => this.updateRotationX(e));
                document.getElementById('rotationYSlider').addEventListener('input', (e) => this.updateRotationY(e));
                document.getElementById('rotationZSlider').addEventListener('input', (e) => this.updateRotationZ(e));
                document.getElementById('resetRotation').addEventListener('click', () => this.resetRotation());

                // Export
                document.getElementById('exportJPG').addEventListener('click', () => this.exportImage('jpg'));
                document.getElementById('exportPNG').addEventListener('click', () => this.exportImage('png'));
                document.getElementById('exportScreenshot').addEventListener('click', () => this.exportScreenshot());
                document.getElementById('shareImage').addEventListener('click', () => this.shareImage());
            }

            setupDragDrop(uploadAreaId, fileInputId) {
                const uploadArea = document.getElementById(uploadAreaId);
                const fileInput = document.getElementById(fileInputId);

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        fileInput.files = files;
                        fileInput.dispatchEvent(new Event('change'));
                    }
                });
            }

            handleRoomUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.roomImage = img;
                        document.getElementById('roomPreview').src = e.target.result;
                        document.getElementById('roomPreview').style.display = 'block';
                        this.scalePoints = [];
                        this.redraw();
                        this.showStatus('Room image loaded! Now click two points to set the scale.', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            handleArtworkUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.artworkImage = img;
                        document.getElementById('artworkPreview').src = e.target.result;
                        document.getElementById('artworkPreview').style.display = 'block';
                        
                        // Create WebGL texture for artwork
                        this.artworkTexture = this.createArtworkTexture(img);
                        
                        this.createArtworkElement(e.target.result);
                        
                        // Set initial size if no width specified yet
                        if (this.artworkWidth === 0) {
                            // Set default size to make artwork visible
                            const defaultSize = 200;
                            const aspectRatio = img.width / img.height;
                            this.artworkSize.width = defaultSize;
                            this.artworkSize.height = defaultSize / aspectRatio;
                            
                            // Center it
                            this.artworkPosition.x = (this.canvas.width - this.artworkSize.width) / 2;
                            this.artworkPosition.y = (this.canvas.height - this.artworkSize.height) / 2;
                            
                            this.updateArtworkElement();
                        } else {
                            this.updateArtworkSize();
                        }
                        
                        this.redraw();
                        this.showStatus('Artwork loaded! Set the artwork width to scale it properly.', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            handleCanvasClick(e) {
                if (!this.roomImage) {
                    this.showStatus('Please upload a room image first.', 'error');
                    return;
                }

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.scalePoints.length < 2) {
                    this.scalePoints.push({ x, y });
                    this.redraw();
                    
                    if (this.scalePoints.length === 2) {
                        this.showStatus('Two points set! Enter the real distance between them.', 'info');
                    } else {
                        this.showStatus('Click a second point to set the scale reference.', 'info');
                    }
                }
            }

            handleMouseDown(e) {
                if (!this.artworkImage) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if click is on artwork
                if (this.artworkImage && x >= this.artworkPosition.x && x <= this.artworkPosition.x + this.artworkSize.width &&
                    y >= this.artworkPosition.y && y <= this.artworkPosition.y + this.artworkSize.height) {
                    this.isDragging = true;
                    this.dragOffset.x = x - this.artworkPosition.x;
                    this.dragOffset.y = y - this.artworkPosition.y;
                    this.canvas.style.cursor = 'grabbing';
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.artworkPosition.x = x - this.dragOffset.x;
                this.artworkPosition.y = y - this.dragOffset.y;

                // Update HTML element position
                this.updateArtworkTransform();
                this.redraw();
            }

            handleMouseUp(e) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                    if (this.artworkElement) {
                        this.artworkElement.style.cursor = 'move';
                    }
                }
            }

            updateScale() {
                this.realDistance = parseFloat(document.getElementById('realDistance').value) || 0;
                this.distanceUnit = document.getElementById('distanceUnit').value;

                if (this.scalePoints.length === 2 && this.realDistance > 0) {
                    const pixelDistance = this.calculateDistance(this.scalePoints[0], this.scalePoints[1]);
                    this.pixelsPerUnit = pixelDistance / this.realDistance;
                    this.updateArtworkSize();
                    this.showStatus('Scale updated! Artwork will now be sized correctly.', 'success');
                }
            }

            updateArtworkSize() {
                this.artworkWidth = parseFloat(document.getElementById('artworkWidth').value) || 0;
                this.artworkUnit = document.getElementById('artworkUnit').value;

                if (this.artworkImage && this.artworkWidth > 0 && this.pixelsPerUnit > 0) {
                    // Convert artwork width to same unit as scale
                    const widthInScaleUnits = this.convertUnits(this.artworkWidth, this.artworkUnit, this.distanceUnit);
                    const pixelWidth = widthInScaleUnits * this.pixelsPerUnit;
                    
                    // Calculate height maintaining original image aspect ratio
                    const originalAspectRatio = this.artworkImage.width / this.artworkImage.height;
                    const pixelHeight = pixelWidth / originalAspectRatio;
                    
                    this.artworkSize.width = pixelWidth;
                    this.artworkSize.height = pixelHeight;

                    // Center artwork initially or when size changes significantly
                    if (this.artworkPosition.x === 0 && this.artworkPosition.y === 0) {
                        this.artworkPosition.x = (this.canvas.width - this.artworkSize.width) / 2;
                        this.artworkPosition.y = (this.canvas.height - this.artworkSize.height) / 2;
                    }

                    // Update HTML element size and position
                    this.updateArtworkElement();
                    this.redraw();
                }
            }

            updateArtworkElement() {
                if (!this.artworkElement) return;

                // Set size
                this.artworkElement.style.width = this.artworkSize.width + 'px';
                this.artworkElement.style.height = this.artworkSize.height + 'px';

                // Update transform with current position and rotation
                this.updateArtworkTransform();
            }

            convertUnits(value, fromUnit, toUnit) {
                const toMeters = {
                    'm': 1,
                    'ft': 0.3048,
                    'cm': 0.01,
                    'in': 0.0254
                };

                const meters = value * toMeters[fromUnit];
                return meters / toMeters[toUnit];
            }

            calculateDistance(point1, point2) {
                const dx = point2.x - point1.x;
                const dy = point2.y - point1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            clearScalePoints() {
                this.scalePoints = [];
                this.pixelsPerUnit = 1;
                this.redraw();
                this.showStatus('Scale points cleared. Click two new points to set scale.', 'info');
            }

            createArtworkElement(imageSrc) {
                // Remove existing artwork element if it exists
                if (this.artworkElement) {
                    this.artworkElement.remove();
                }

                // Create new artwork element
                this.artworkElement = document.createElement('div');
                this.artworkElement.className = 'artwork-element';
                this.artworkElement.style.backgroundImage = `url(${imageSrc})`;
                
                // Hide CSS artwork element when using WebGL
                if (this.gl) {
                    this.artworkElement.style.display = 'none';
                }
                
                // Add to canvas container
                const canvasContainer = document.querySelector('.canvas-container');
                canvasContainer.appendChild(this.artworkElement);

                // Add drag functionality
                this.setupArtworkDragging();
            }

            setupArtworkDragging() {
                if (!this.artworkElement) return;

                this.artworkElement.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    const rect = this.canvas.getBoundingClientRect();
                    this.dragOffset.x = e.clientX - rect.left - this.artworkPosition.x - this.artworkSize.width / 2;
                    this.dragOffset.y = e.clientY - rect.top - this.artworkPosition.y - this.artworkSize.height / 2;
                    this.artworkElement.style.cursor = 'grabbing';
                    e.preventDefault();
                });

                // Use the existing mouse move and mouse up handlers
            }

            updateRotationX(e) {
                this.artworkRotation.x = parseInt(e.target.value);
                document.getElementById('rotationXValue').textContent = this.artworkRotation.x + '¬∞';
                this.updateArtworkTransform();
                this.renderWebGLArtwork(); // Update WebGL render
            }

            updateRotationY(e) {
                this.artworkRotation.y = parseInt(e.target.value);
                document.getElementById('rotationYValue').textContent = this.artworkRotation.y + '¬∞';
                this.updateArtworkTransform();
                this.renderWebGLArtwork(); // Update WebGL render
            }

            updateRotationZ(e) {
                this.artworkRotation.z = parseInt(e.target.value);
                document.getElementById('rotationZValue').textContent = this.artworkRotation.z + '¬∞';
                this.updateArtworkTransform();
                this.renderWebGLArtwork(); // Update WebGL render
            }

            resetRotation() {
                this.artworkRotation = { x: 0, y: 0, z: 0 };
                document.getElementById('rotationXSlider').value = 0;
                document.getElementById('rotationYSlider').value = 0;
                document.getElementById('rotationZSlider').value = 0;
                document.getElementById('rotationXValue').textContent = '0¬∞';
                document.getElementById('rotationYValue').textContent = '0¬∞';
                document.getElementById('rotationZValue').textContent = '0¬∞';
                this.updateArtworkTransform();
                this.renderWebGLArtwork(); // Update WebGL render
            }

            updateArtworkTransform() {
                if (!this.artworkElement) return;

                // Position relative to the canvas container
                this.artworkElement.style.left = this.artworkPosition.x + 'px';
                this.artworkElement.style.top = this.artworkPosition.y + 'px';
                this.artworkElement.style.transform = 
                    `perspective(500px) rotateX(${this.artworkRotation.x}deg) rotateY(${this.artworkRotation.y}deg) rotateZ(${this.artworkRotation.z}deg)`;
            }


            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw room image - maintain aspect ratio and store dimensions
                if (this.roomImage) {
                    const scale = Math.min(
                        this.canvas.width / this.roomImage.width,
                        this.canvas.height / this.roomImage.height
                    );
                    this.roomImageDisplayed = {
                        width: this.roomImage.width * scale,
                        height: this.roomImage.height * scale,
                        x: (this.canvas.width - this.roomImage.width * scale) / 2,
                        y: (this.canvas.height - this.roomImage.height * scale) / 2,
                        scale: scale
                    };

                    this.ctx.drawImage(this.roomImage, 
                        this.roomImageDisplayed.x, 
                        this.roomImageDisplayed.y, 
                        this.roomImageDisplayed.width, 
                        this.roomImageDisplayed.height);
                }

                // Draw scale points
                this.scalePoints.forEach((point, index) => {
                    this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                    this.ctx.fill();

                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px DIN Light Alternate, Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(index + 1, point.x, point.y + 4);
                });

                // Draw measurement line
                if (this.scalePoints.length === 2) {
                    this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.scalePoints[0].x, this.scalePoints[0].y);
                    this.ctx.lineTo(this.scalePoints[1].x, this.scalePoints[1].y);
                    this.ctx.stroke();

                    if (this.realDistance > 0) {
                        const midX = (this.scalePoints[0].x + this.scalePoints[1].x) / 2;
                        const midY = (this.scalePoints[0].y + this.scalePoints[1].y) / 2;
                        
                        this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
                        this.ctx.fillRect(midX - 30, midY - 10, 60, 20);
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '12px DIN Light Alternate, Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`${this.realDistance} ${this.distanceUnit}`, midX, midY + 4);
                    }
                }

                // Render artwork using WebGL for accurate 3D transforms
                this.renderWebGLArtwork();
            }

            renderWebGLArtwork() {
                if (!this.gl || !this.artworkTexture || !this.shaderProgram) {
                    return; // Fall back to CSS transforms if WebGL not available
                }

                const gl = this.gl;
                
                // Clear WebGL canvas with transparent background
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Use shader program
                gl.useProgram(this.shaderProgram);

                // Set up geometry
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.position);
                gl.vertexAttribPointer(this.programInfo.attribLocations.position, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.texCoord);
                gl.vertexAttribPointer(this.programInfo.attribLocations.texCoord, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

                // Set up texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.artworkTexture);
                gl.uniform1i(this.programInfo.uniformLocations.texture, 0);

                // Calculate transformation matrix
                const matrix = this.calculateArtworkTransformMatrix();
                gl.uniformMatrix4fv(this.programInfo.uniformLocations.matrix, false, matrix);

                // Draw the artwork
                gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
            }

            calculateArtworkTransformMatrix() {
                if (!this.artworkImage || this.artworkSize.width === 0) {
                    return this.createMatrix();
                }

                // Convert canvas coordinates to WebGL normalized coordinates (-1 to 1)
                const canvasWidth = this.webglCanvas.width;
                const canvasHeight = this.webglCanvas.height;
                
                // Calculate artwork center in normalized coordinates
                const centerX = ((this.artworkPosition.x + this.artworkSize.width / 2) / canvasWidth) * 2 - 1;
                const centerY = -(((this.artworkPosition.y + this.artworkSize.height / 2) / canvasHeight) * 2 - 1); // Flip Y

                // Calculate scale to match artwork size
                const scaleX = this.artworkSize.width / canvasWidth;
                const scaleY = this.artworkSize.height / canvasHeight;

                // Create transformation matrix
                let matrix = this.createMatrix();
                
                // Apply transformations in order: scale, rotate, translate
                matrix = this.multiplyMatrices(matrix, this.scaleMatrix(scaleX, scaleY, 1));
                
                // Apply rotations (convert degrees to radians)
                const xRad = (this.artworkRotation.x * Math.PI) / 180;
                const yRad = (this.artworkRotation.y * Math.PI) / 180;
                const zRad = (this.artworkRotation.z * Math.PI) / 180;
                
                matrix = this.multiplyMatrices(matrix, this.rotationXMatrix(xRad));
                matrix = this.multiplyMatrices(matrix, this.rotationYMatrix(yRad));
                matrix = this.multiplyMatrices(matrix, this.rotationZMatrix(zRad));
                
                // Apply translation to position
                matrix = this.multiplyMatrices(matrix, this.translationMatrix(centerX, centerY, 0));

                return matrix;
            }

            async exportImage(format) {
                if (!this.roomImage) {
                    this.showStatus('No room image to export.', 'error');
                    return;
                }

                try {
                    this.showStatus('Generating export image...', 'info');
                    
                    // Create composite canvas
                    const exportCanvas = document.createElement('canvas');
                    const exportCtx = exportCanvas.getContext('2d');
                    const scale = window.devicePixelRatio || 1;
                    
                    exportCanvas.width = this.canvas.width * scale;
                    exportCanvas.height = this.canvas.height * scale;
                    exportCtx.scale(scale, scale);

                    // Fill background for JPG format
                    if (format === 'jpg' || format === 'jpeg') {
                        exportCtx.fillStyle = '#ffffff';
                        exportCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }

                    // Draw the main canvas (room image and measurement lines)
                    exportCtx.drawImage(this.canvas, 0, 0);

                    // Draw the WebGL canvas with accurate 3D artwork
                    if (this.gl && this.webglCanvas) {
                        exportCtx.drawImage(this.webglCanvas, 0, 0);
                    } else if (this.artworkImage) {
                        // Fallback to manual 3D rotation if WebGL not available
                        this.drawArtworkWith3DRotation(exportCtx);
                    }

                    const dataURL = exportCanvas.toDataURL(format === 'jpg' ? 'image/jpeg' : 'image/png', 0.92);
                    const link = document.createElement('a');
                    link.download = `your-world-our-art.${format === 'jpg' ? 'jpg' : 'png'}`;
                    link.href = dataURL;
                    link.click();
                    
                    this.showStatus(`Image exported as ${format.toUpperCase()}!`, 'success');
                } catch (error) {
                    console.error('Export error:', error);
                    this.showStatus('Export failed. Please try again.', 'error');
                }
            }

            async exportScreenshot() {
                if (!this.roomImage) {
                    this.showStatus('No room image to export.', 'error');
                    return;
                }

                try {
                    this.showStatus('Click to share your screen, then select this browser tab.', 'info');
                    
                    // Request screen capture
                    const stream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            displaySurface: "browser",
                            preferCurrentTab: true
                        },
                        audio: false
                    });

                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.playsInline = true;
                    await video.play();

                    // Wait for video to be ready
                    await new Promise(resolve => {
                        if (video.readyState >= 2) resolve();
                        else video.onloadedmetadata = resolve;
                    });

                    // Capture one frame
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);

                    // Stop the capture
                    stream.getTracks().forEach(track => track.stop());

                    // Crop to canvas container area
                    const container = document.querySelector('.canvas-container');
                    const rect = container.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    
                    const cropX = Math.round(rect.left * dpr);
                    const cropY = Math.round(rect.top * dpr);
                    const cropW = Math.round(rect.width * dpr);
                    const cropH = Math.round(rect.height * dpr);

                    const croppedCanvas = document.createElement('canvas');
                    const croppedCtx = croppedCanvas.getContext('2d');
                    croppedCanvas.width = cropW;
                    croppedCanvas.height = cropH;
                    
                    croppedCtx.drawImage(
                        canvas,
                        cropX, cropY, cropW, cropH,
                        0, 0, cropW, cropH
                    );

                    // Download the result
                    const dataURL = croppedCanvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'your-world-our-art-screenshot.png';
                    link.href = dataURL;
                    link.click();
                    
                    this.showStatus('Screenshot exported successfully!', 'success');
                } catch (error) {
                    console.error('Screenshot error:', error);
                    this.showStatus('Screenshot failed. Screen sharing may not be supported.', 'error');
                }
            }

            drawArtworkWith3DRotation(ctx) {
                if (!this.artworkImage) return;

                ctx.save();
                
                // Calculate artwork center
                const centerX = this.artworkPosition.x + this.artworkSize.width / 2;
                const centerY = this.artworkPosition.y + this.artworkSize.height / 2;
                
                // Move to center point
                ctx.translate(centerX, centerY);
                
                // Convert rotations to radians
                const xRad = (this.artworkRotation.x * Math.PI) / 180;
                const yRad = (this.artworkRotation.y * Math.PI) / 180;
                const zRad = (this.artworkRotation.z * Math.PI) / 180;
                
                // Apply 3D rotation matrix calculations
                // For proper 3D effect, we need to simulate perspective projection
                const perspective = 500; // Same as CSS perspective value
                
                // Calculate 3D rotation matrix components
                const cosX = Math.cos(xRad);
                const sinX = Math.sin(xRad);
                const cosY = Math.cos(yRad);
                const sinY = Math.sin(yRad);
                const cosZ = Math.cos(zRad);
                const sinZ = Math.sin(zRad);
                
                // Combined rotation matrix (Z * Y * X order, same as CSS)
                const m11 = cosY * cosZ;
                const m12 = -cosY * sinZ;
                const m13 = sinY;
                
                const m21 = cosX * sinZ + sinX * sinY * cosZ;
                const m22 = cosX * cosZ - sinX * sinY * sinZ;
                const m23 = -sinX * cosY;
                
                const m31 = sinX * sinZ - cosX * sinY * cosZ;
                const m32 = sinX * cosZ + cosX * sinY * sinZ;
                const m33 = cosX * cosY;
                
                // Apply perspective projection (simplified)
                const perspectiveScale = perspective / (perspective + m13 * 100);
                
                // Apply the 2D projection of 3D rotation
                ctx.transform(
                    m11 * perspectiveScale,  // x scale and skew
                    m21 * perspectiveScale,  // x skew
                    m12 * perspectiveScale,  // y skew  
                    m22 * perspectiveScale,  // y scale
                    0,                       // x translation
                    0                        // y translation
                );
                
                // Apply additional Y-axis foreshortening for better 3D effect
                const yForeshorten = Math.abs(cosY);
                if (yForeshorten < 1) {
                    ctx.transform(yForeshorten, 0, 0, 1, 0, 0);
                }
                
                // Draw the artwork centered at origin
                ctx.drawImage(
                    this.artworkImage,
                    -this.artworkSize.width / 2,
                    -this.artworkSize.height / 2,
                    this.artworkSize.width,
                    this.artworkSize.height
                );
                
                ctx.restore();
            }

            async shareImage() {
                if (!this.roomImage) {
                    this.showStatus('No room image to share.', 'error');
                    return;
                }

                try {
                    this.showStatus('Generating image for sharing...', 'info');
                    
                    // Create share canvas
                    const shareCanvas = document.createElement('canvas');
                    const shareCtx = shareCanvas.getContext('2d');
                    
                    shareCanvas.width = this.canvas.width;
                    shareCanvas.height = this.canvas.height;

                    // Draw the main canvas (room image and measurement lines)
                    shareCtx.drawImage(this.canvas, 0, 0);

                    // Draw the WebGL canvas with accurate 3D artwork
                    if (this.gl && this.webglCanvas) {
                        shareCtx.drawImage(this.webglCanvas, 0, 0);
                    } else if (this.artworkImage) {
                        // Fallback to manual 3D rotation if WebGL not available
                        this.drawArtworkWith3DRotation(shareCtx);
                    }

                    shareCanvas.toBlob((blob) => {
                        if (navigator.share && navigator.canShare({ files: [blob] })) {
                            const file = new File([blob], 'your-world-our-art.png', { type: 'image/png' });
                            navigator.share({
                                title: 'Your World, Our Art',
                                text: 'Check out how this artwork looks in my space!',
                                files: [file]
                            });
                        } else {
                            // Fallback: copy to clipboard
                            navigator.clipboard.write([
                                new ClipboardItem({ 'image/png': blob })
                            ]).then(() => {
                                this.showStatus('Image copied to clipboard!', 'success');
                            }).catch(() => {
                                this.showStatus('Sharing not supported. Use export instead.', 'error');
                            });
                        }
                    });
                } catch (error) {
                    console.error('Share error:', error);
                    this.showStatus('Share failed. Please try again.', 'error');
                }
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('statusMessages');
                statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
                setTimeout(() => {
                    if (statusDiv.innerHTML.includes(message)) {
                        statusDiv.innerHTML = '';
                    }
                }, 5000);
            }
        }

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new YWOAApp();
        });
    </script>
</body>
</html>